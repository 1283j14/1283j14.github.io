html
<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<title>Hyper Rogue TD Neo - Ver.0.2.1</title>
<style>
  :root{
    --bg:#050914;
    --panel:#0f1724; --accent:#2ee6ff;
    --common:#b0b0b0; --uncommon:#44ff44;
    --rare:#2e8cff; --epic:#a335ee; --legend:#ffaa00;
    --mythic:#ff0055; --danger:#ff4d4d;
    --text-main:#eaf6ff;
    --shadow-text: 2px 2px 0px rgba(0,0,0,0.8);
  }
  html,body{height:100%;margin:0;font-family:'Courier New', sans-serif;background:var(--bg);color:var(--text-main);overflow:hidden;user-select:none;}

  /* --- LAYOUT --- */
  .screen {
    position:absolute;
    top:0; left:0; width:100%; height:100%;
    background:var(--bg); z-index:10;
    display:flex; flex-direction:column;
  }
  .hidden {display:none !important;}

  /* GAME SCREEN */
  #gameScreen {
    display:flex;
    flex-direction:row;
    height:100vh; gap:12px; padding:12px; box-sizing:border-box;
    position:relative;
  }

  /* LEFT SIDE */
  #left {
    flex:1; display:flex;
    flex-direction:column; gap:0; position:relative;
    height: 100%; border-radius:8px; overflow: hidden;
    box-shadow:inset 0 0 20px rgba(0,0,0,0.8);
  }
  canvas {
    background:#070b1a; display:block; width:100%; height:100%;
    cursor:crosshair;
  }

  /* RIGHT SIDE */
  #right {
    width:360px; display:flex; flex-direction:column; gap:8px; z-index:5;
    height: 100%;
  }
  .panel{
    background:rgba(12, 18, 28, 0.95); padding:10px; border-radius:6px; border:1px solid #23344a;
    display:flex; flex-direction:column; gap:5px;
    box-shadow: 0 4px 10px rgba(0,0,0,0.5);
  }
  .panel.grow { flex: 1; min-height: 0;
  }

  /* --- UI COMPONENTS --- */
  h3{
      margin:0 0 5px 0;
      font-size:0.85rem; color:var(--accent);
      border-bottom:1px solid #23344a; padding-bottom:5px;
      display:flex; justify-content:space-between; text-shadow: 1px 1px 0 #000;
  }

  .btn {background:linear-gradient(180deg, #1a273a, #0f1724);border:1px solid var(--accent);color:var(--accent);padding:8px;cursor:pointer;border-radius:4px;transition:0.2s;font-weight:bold;font-family:inherit;
    text-shadow: 1px 1px 0 #000;}
  .btn:hover {background:var(--accent);color:#000;box-shadow:0 0 10px var(--accent);
    text-shadow: none;}
  .btn:disabled {border-color:#555;color:#555;pointer-events:none;background:#111;}

  .btn-big {padding:15px 40px; font-size:1.2rem; margin-top:30px; margin-bottom: 50px;}
  .btn-danger {border-color:var(--danger);
    color:var(--danger);}
  .btn-danger:hover {background:var(--danger); color:#000; box-shadow:0 0 10px var(--danger);}

  /* HUD */
  #hud {
    position:absolute;
    top:10px; left:10px; right:10px; height:40px;
    display:flex; gap:15px; pointer-events:none; z-index: 100;
  }
  .stat {background:rgba(15,23,36,0.9);padding:5px 15px;border-radius:4px;border:1px solid rgba(46,230,255,0.3);backdrop-filter:blur(4px);pointer-events:auto; height: 100%;
    box-sizing: border-box;}
  .label {font-size:0.6rem;color:var(--accent);opacity:0.8;letter-spacing:1px; text-shadow: 1px 1px 0 #000;}
  .val {font-size:1.1rem;font-weight:bold;color:#fff;
    text-shadow: 2px 2px 0 #000;}
  .controls {pointer-events:auto; display:flex; gap:10px; align-items:center;}

  .speed-ctrl { display:flex; gap:2px; background:#000; border-radius:4px;
    overflow:hidden; border:1px solid #444; }
  .spd-btn { background:#111; color:#888; border:none; padding:5px 10px; font-size:0.8rem; cursor:pointer; font-weight:bold;
  }
  .spd-btn.active { background:var(--accent); color:#000; }

  /* OVERLAYS */
  #pauseOverlay, #modalOverlay, #newsOverlay, #retryOverlay, #gameOverOverlay {
    position:absolute;
    top:0; left:0; width:100%; height:100%;
    background:rgba(0,0,0,0.85); backdrop-filter:blur(5px); z-index:150;
    display:flex; flex-direction:column; justify-content:center; align-items:center; gap:20px;
  }
  #modalOverlay { z-index: 2000;
  }
  #retryOverlay { background: rgba(50, 0, 0, 0.8); z-index: 3000; }
  #gameOverOverlay { z-index: 4000; background: rgba(0,0,0,0.95); }

  .retry-title { font-size: 2.5rem;
    color: var(--danger); font-weight: bold; text-shadow: 0 0 20px var(--danger); animation: pulseRed 0.5s infinite alternate; }
  .retry-sub { font-size: 1.0rem;
    color: #fff; margin-top: 10px; }
  .pause-title {font-size:3rem; color:var(--accent); letter-spacing:5px;
    text-shadow:0 0 15px var(--accent);}

  .go-title { font-size: 4rem; color: var(--danger); letter-spacing: 5px; text-shadow: 0 0 20px var(--danger); margin-bottom: 20px; }
  .go-stat { font-size: 1.5rem; color: #fff; }
  .go-cf { font-size: 1.2rem; color: var(--legend); margin-top: 10px; }

  /* EVENT HUD */
  #eventHud {
      position: absolute; top: 60px; left: 10px; z-index: 90;
      display: flex; flex-direction: column; gap: 5px; pointer-events: none;
  }
  .event-tag {
      background: rgba(100, 0, 200, 0.7); border: 1px solid #d000ff;
      padding: 5px 10px; border-radius: 4px; color: #fff; font-size: 0.8rem;
      text-shadow: 0 0 5px #d000ff; animation: pulseEvent 1s infinite alternate;
      cursor: pointer; pointer-events: auto;
  }
  .event-tag.nerf { background: rgba(200, 50, 0, 0.7); border-color: #ff4d4d; text-shadow: 0 0 5px #ff0000; }
  .event-tag.mixed { background: rgba(200, 150, 0, 0.7); border-color: #ffaa00; text-shadow: 0 0 5px #ff8800; }
  @keyframes pulseEvent { 0% { transform: scale(1); opacity: 0.9; } 100% { transform: scale(1.05); opacity: 1; } }

  /* BOSS HUD */
  #bossHud {
    position:absolute; top:60px; left:50%; transform:translateX(-50%); width:70%;
    z-index:90; display:flex; flex-direction:column; align-items:center; pointer-events:none;
    text-shadow:0 0 5px #000; background: rgba(0,0,0,0.6); padding: 10px; border-radius: 8px; border: 1px solid var(--danger);
  }
  .boss-warning { font-size: 1.0rem; color: var(--danger); font-weight: bold; letter-spacing: 3px; animation: blink 1s infinite; margin-bottom: 5px;
  }
  .boss-bar-bg {width:100%; height:16px; background:#300; border:1px solid #500; border-radius:4px; overflow:hidden; position:relative;}
  .boss-bar-fill {height:100%; background:linear-gradient(90deg, #f00, #a00); width:0%;
    transition:width 0.1s;}
  .boss-val {font-size:0.9rem; color:#fff; margin-top:2px; font-weight: bold;}

  /* GOLD RUSH OVERLAY */
  #goldRushOverlay {
    position: absolute;
    top: 150px; left: 50%; transform: translateX(-50%);
    color: #ffd700; font-size: 2rem; font-weight: bold;
    text-shadow: 0 0 20px #ffd700, 2px 2px 0 #000;
    z-index: 80; pointer-events: none;
    animation: flashGold 0.5s infinite alternate;
  }

  /* ANIMATIONS */
  @keyframes flashGold { 0% { opacity: 0.6; transform: translateX(-50%) scale(1);
  } 100% { opacity: 1; transform: translateX(-50%) scale(1.1); } }
  @keyframes pulseRed { 0% { opacity: 0.7;
  } 100% { opacity: 1.0; } }
  @keyframes blink { 50% { opacity: 0.5;
  } }

  /* MENU SCREEN */
  #upgradeScreen {padding:20px; overflow-y:auto; align-items:center; background:var(--bg);}
  .header {width:100%; max-width:1000px; display:flex; justify-content:space-between; align-items:flex-end;
    border-bottom:1px solid #333; padding-bottom:10px; margin-bottom:20px;}
  .cf-display {font-size:1.5rem; color:var(--legend); font-weight:bold; text-shadow:0 0 10px var(--legend);}
  .tabs {display:flex; gap:10px;
    margin-bottom:15px;}
  .tab-btn {background:#111; border:1px solid #444; color:#888; padding:8px 20px; cursor:pointer; transition:0.2s;}
  .tab-btn.active {background:var(--accent); color:#000; border-color:var(--accent);
    font-weight:bold;}
  .tree-container {display:flex; flex-wrap:wrap; gap:15px; max-width:1000px; justify-content:center; padding-bottom: 20px;}
  .skill-node { width:220px; background:#0f1724; border:1px solid #333; padding:10px; border-radius:4px;
    display:flex; flex-direction:column; gap:4px; transition:0.2s; position:relative; opacity:0.6; }
  .skill-node.unlocked {border-color:var(--accent); opacity:1.0; box-shadow:0 0 5px var(--accent);}
  .skill-node.affordable {border-color:var(--legend); opacity:0.9;
    cursor:pointer;}
  .skill-node.affordable:hover {transform:translateY(-3px); box-shadow:0 0 10px var(--legend);}
  .skill-name {font-weight:bold; color:var(--accent); font-size:0.9rem;}
  .skill-desc {font-size:0.7rem; color:#ccc;
    min-height:30px;}
  .skill-cost {font-size:0.8rem; color:var(--legend); text-align:right;}
  .skill-owned {position:absolute; top:5px; right:5px; color:var(--accent);
    font-size:1.2rem;}

  /* STATS BOX */
  .stats-box { background:rgba(15,23,36,0.95); border:1px solid #444; border-radius:8px; padding:15px; display:grid; grid-template-columns: repeat(4, 1fr);
    gap:10px 20px; font-size:0.75rem; width:80%; max-width:800px; margin-bottom:20px; box-shadow: 0 4px 15px rgba(0,0,0,0.5); }
  .stat-item {display:flex; justify-content:space-between; border-bottom:1px solid #333;
    padding-bottom:2px;}
  .stat-name {color:#aaa;}
  .stat-val {color:var(--accent); font-weight:bold;}

  /* MISC UI */
  .shop-grid {display:grid;grid-template-columns:1fr 1fr;gap:4px;}
  .tech-btn {font-size:0.75rem;
    display:flex; justify-content:space-between; align-items:center;}
  #artifacts {display:flex; flex-wrap:wrap; gap:6px; align-content: flex-start; overflow-y:auto; max-height:100%;}
  .artifact { width:32px; height:32px; background:#111;
    border:1px solid #444; border-radius:4px; display:flex; align-items:center; justify-content:center; font-size:10px; cursor:pointer; position:relative; transition:0.3s; font-weight: bold; }
  .artifact:hover { border-color: #fff;
    box-shadow: 0 0 5px #fff; }
  .artifact-count {position: absolute; bottom: -5px; right: -5px; background: #000; color: #fff; font-size: 8px;
    padding: 1px 3px; border-radius: 4px; border: 1px solid #555; pointer-events: none;}

  /* GLOBAL TOOLTIP */
  #globalTooltip { position: absolute;
    pointer-events: none; z-index: 9999; background: rgba(0,0,0,0.95); border: 1px solid var(--accent); padding: 10px; border-radius: 4px; color: #fff; font-size: 0.75rem; white-space: pre-wrap;
    max-width: 250px; box-shadow: 0 4px 15px rgba(0,0,0,0.8); display: none; line-height: 1.4;
  }

  /* SECRET INPUT */
  #secretCode { position: fixed; bottom: 15px; right: 15px; width: 100px; background: rgba(0,0,0,0.8);
    border: 1px solid #444; color: #aaa; font-family: monospace; font-size: 0.8rem; text-align: center; padding: 5px; opacity: 0.5; transition: 0.3s; z-index: 10000;
  }
  #secretCode:hover, #secretCode:focus { opacity: 1.0; color: var(--accent); border-color: var(--accent);
  }

  /* NEWS BUTTON (5% from Right) */
  #newsBtn { position: absolute; top: 15px; right: 5%;
    background: var(--panel); border: 1px solid var(--accent); color: var(--accent); padding: 5px 15px; cursor: pointer; font-size: 0.8rem; font-weight: bold; z-index: 100;
  }
  #newsBtn:hover { background: var(--accent); color: #000; }

  /* CARDS & RARITIES */
  .card-container {display:flex;gap:15px;margin-top:20px;flex-wrap:wrap;justify-content:center;max-width: 90%;
    max-height: 80vh; overflow-y: auto;}
  .card { width:180px; padding:15px; border-radius:8px; cursor:pointer; transition:0.3s; display:flex; flex-direction:column; justify-content:space-between; position:relative; overflow:hidden;
    border: 2px solid #444; background: #111; background-image: radial-gradient(#ffffff05 1px, transparent 1px); background-size: 10px 10px; }
  .card:hover { transform:translateY(-10px);
    box-shadow:0 0 25px rgba(255,255,255,0.2); }
  .card h4 {margin:0 0 8px 0; color:#fff; font-size:0.95rem;
    text-shadow: 1px 1px 2px #000;}
  .card p {font-size:0.75rem; color:#ddd; line-height:1.4;
    text-shadow: 1px 1px 1px #000;}

  /* Rarity Colors */
  .common { border-color: var(--common); color: var(--common);
  }
  .card.common { background: linear-gradient(135deg, #222, #333); }
  .uncommon { border-color: var(--uncommon); color: var(--uncommon);
    box-shadow: 0 0 2px var(--uncommon); }
  .card.uncommon { background: linear-gradient(135deg, #0a1f0a, #143314); border-color: var(--uncommon);
  }
  .rare { border-color: var(--rare); color: var(--rare); box-shadow: 0 0 4px var(--rare);
  }
  .card.rare { background: linear-gradient(135deg, #0a0a2e, #14144d); border-color: var(--rare); }
  .epic { border-color: var(--epic); color: var(--epic);
    box-shadow: 0 0 6px var(--epic); }
  .card.epic { background: linear-gradient(135deg, #1f0a2e, #33144d); border-color: var(--epic);
  }
  .legendary { border-color: var(--legend); color: var(--legend); box-shadow: 0 0 8px var(--legend); animation: pulseLeg 2s infinite;
  }
  .card.legendary { background: linear-gradient(135deg, #2e1f0a, #4d3314); border-color: var(--legend); }
  .mythic { border-color: var(--mythic); color: var(--mythic);
    box-shadow: 0 0 10px var(--mythic); animation: pulseMy 1.5s infinite; }
  .card.mythic { background: linear-gradient(135deg, #2e0a14, #4d1429); border-color: var(--mythic);
  }

  .card.starter { border-color: #fff; background: linear-gradient(135deg, #111, #222); height: 160px; width: 150px;
  }
  .card.starter:hover { border-color: var(--accent); box-shadow: 0 0 15px var(--accent);
  }

  @keyframes pulseLeg {0%{box-shadow:0 0 5px var(--legend);} 50%{box-shadow:0 0 20px var(--legend);} 100%{box-shadow:0 0 5px var(--legend);}}
  @keyframes pulseMy {0%{box-shadow:0 0 5px var(--mythic);} 50%{box-shadow:0 0 25px var(--mythic);} 100%{box-shadow:0 0 5px var(--mythic);}}

  /* NEWS PANEL */
  .news-panel { background: #0f1724;
    border: 1px solid var(--accent); border-radius: 8px; padding: 30px; max-width: 600px; width: 90%; max-height: 80vh; overflow-y: auto;
    box-shadow: 0 0 30px rgba(46,230,255,0.2); }
  .news-header { font-size: 1.5rem; color: var(--accent); margin-bottom: 15px; border-bottom: 1px solid #333;
    padding-bottom: 10px; }
  .news-content { font-size: 0.9rem; line-height: 1.6; color: #ddd; }
  .news-content li { margin-bottom: 8px;
  }

  /* DPS METER & LOG LAYOUT */
  #dpsMeter { position:absolute; bottom:10px; left:10px; width:200px; background:rgba(0,0,0,0.8); border:1px solid #444;
    border-radius:6px; padding:8px; pointer-events:none; font-size:0.7rem; display:flex; flex-direction:column; gap:4px; z-index: 50; }
  .dps-row {display:flex; align-items:center; gap:5px;}
  .dps-bar-bg {flex:1; height:6px; background:#222;
    border-radius:3px; overflow:hidden;}
  .dps-bar-fill {height:100%; background:var(--accent); transition:width 0.5s;}

  /* LOG OVERLAY (Center-Right) */
  #ingameLog {
    position:absolute;
    bottom:10px; left: 65%; transform: translateX(-50%);
    width:450px; height:60px; background:rgba(0,0,0,0.6); border:1px solid #444; border-radius:6px;
    padding:5px 10px; pointer-events:none; font-size:0.7rem; font-family: monospace; color:#ccc;
    display:flex;
    flex-direction:column; justify-content:flex-end; overflow:hidden;
    z-index: 50; pointer-events: auto; text-shadow: 1px 1px 0 #000;
  }
  #logContent { overflow-y: auto; max-height: 100%;
    display: flex; flex-direction: column-reverse;}
  .log-entry { margin-bottom: 1px; border-left: 2px solid #555; padding-left: 5px; background: rgba(0,0,0,0.3);
  }

</style>
</head>
<body>

<div id="globalTooltip"></div>

<input type="password" id="secretCode" placeholder="CODE">

<div id="newsOverlay" class="screen hidden">
    <div class="news-panel">
        <div class="news-header">PATCH NOTES: Ver.0.2.1</div>
        <div class="news-content">
            <ul>
                <li><strong>[NEW] MONOLITH Enemy:</strong> Ultra-tank that spawns mid-path (Wave 20+).</li>
                <li><strong>[NEW] 8 Event Types:</strong> Armor Surge, Night Vision, Magnetic Field, Anomaly Rift, Titan Rage, Hyper Rift + existing events.</li>
                <li><strong>[NEW] Artifacts:</strong> Assassin Scope (HP-based DMG) & Echo Round (delayed DMG).</li>
                <li><strong>[FIX] Mythic System:</strong> Each mythic now tracked separately - no duplicates in same run.</li>
                <li><strong>[FIX] Code Input:</strong> Now requires Enter key to submit.</li>
                <li><strong>[BALANCE] Artifact Values:</strong> Rebalanced for better progression curve.</li>
            </ul>
        </div>
        <button class="btn btn-big" onclick="closeNews()">ACKNOWLEDGE</button>
    </div>
</div>

<div id="upgradeScreen" class="screen">
  <div class="header">
    <div>
      <h1 style="margin:0; text-shadow:0 0 10px var(--accent);">SYSTEM CORE // UPGRADE</h1>
      <div style="color:#666; font-size:0.8rem;">HYPER ROGUE TD NEO - Ver.0.2.1</div>
    </div>
    <div class="cf-display">CORE FRAGMENTS: <span id="cfVal">0</span></div>
  </div>

  <button id="newsBtn" onclick="openNews()">NEWS</button>

  <div class="tabs">
    <button class="tab-btn active" onclick="switchTab('nexus_core')">NEXUS CORE</button>
    <button class="tab-btn" onclick="switchTab('artifact_mastery')">ARTIFACTS</button>
    <button class="tab-btn" onclick="switchTab('weapon_system')">WEAPONS</button>
    <button class="tab-btn" onclick="switchTab('paradox')">PARADOX</button>
  </div>

  <div id="treeView" class="tree-container"></div>

  <button class="btn btn-big" onclick="startGameFromMenu()">INITIALIZE MISSION</button>
</div>

<div id="gameOverOverlay" class="screen hidden">
  <div class="go-title">MISSION FAILED</div>
  <div class="go-stat">WAVES CLEARED: <span id="goWave">0</span></div>
  <div class="go-cf">CORE FRAGMENTS GAINED: +<span id="goCf">0</span></div>
  <button class="btn btn-big" onclick="returnToMenu()">RETURN TO SYSTEM</button>
</div>

<div id="gameScreen" class="screen hidden">
  <div id="left">
    <div id="flashOverlay" class="hidden"></div>

    <canvas id="c"></canvas>

    <div id="eventHud"></div>

    <div id="bossHud" class="hidden">
      <div class="boss-label">⚠ ANOMALY DETECTED ⚠</div>
      <div class="boss-bar-bg"><div class="boss-bar-fill" id="bossBarFill"></div></div>
      <div class="boss-val" id="bossHpVal"></div>
    </div>

    <div id="goldRushOverlay" class="hidden">GOLD RUSH!!</div>

    <div id="retryOverlay" class="hidden">
        <div class="retry-title">WARNING</div>
        <div class="retry-sub">BREACH DETECTED / RETRYING...</div>
    </div>

    <div id="pauseOverlay" class="hidden">
      <div class="pause-title">PAUSED</div>
      <div id="pauseStats" class="stats-box"></div>
      <button class="btn btn-big" onclick="togglePause()">RESUME</button>
      <button class="btn btn-big btn-danger" onclick="retireGame()">RETIRE (GIVE UP)</button>
    </div>

    <div id="hud">
      <div class="stat"><div class="label">CREDITS</div><div class="val" id="gold">0</div></div>
      <div class="stat"><div class="label">INTEGRITY</div><div class="val" id="life">20</div></div>
      <div class="stat"><div class="label">WAVE</div><div class="val" id="wave">0</div></div>
      <div class="stat hidden" id="goldRushInd"><div class="label">BONUS</div><div class="val" style="color:#ffd700;font-size:0.9rem;">GOLD RUSH</div></div>

      <div class="stat" style="display:flex;
        align-items:center; gap:5px; padding:0 10px;">
          <div class="label">SPEED</div>
          <div class="speed-ctrl">
              <button class="spd-btn active" id="btnSpd1" onclick="setSpeed(1)">x1</button>
              <button class="spd-btn" id="btnSpd15" onclick="setSpeed(1.5)">x1.5</button>
              <button class="spd-btn" id="btnSpd2" onclick="setSpeed(2)">x2</button>
          </div>
      </div>

      <div style="flex:1"></div>
      <div class="controls">
        <div class="switch-container" style="background:rgba(0,0,0,0.5);padding:5px;border-radius:4px;display:flex;gap:5px;">
          <input type="checkbox" id="autoStartCheck">
          <label for="autoStartCheck" style="font-size:0.7rem;cursor:pointer;">AUTO START</label>
        </div>
        <button class="btn" onclick="togglePause()" style="font-family:monospace;
          font-weight:bold;">||</button>
        <button id="nextWaveBtn" class="btn" onclick="triggerWave()">START [ENTER]</button>
      </div>
    </div>

    <div id="dpsMeter">
      <div style="text-align:center;
        color:#888; margin-bottom:4px;">DPS MONITOR</div>
      <div id="dpsList"></div>
    </div>

    <div id="ingameLog">
       <div id="logContent"></div>
    </div>
  </div>

  <div id="right">
    <div class="panel">
      <h3>WEAPON SHOP</h3>
      <div id="shopList" class="shop-grid"></div>
      <div style="font-size:0.65rem;text-align:center;color:#666;margin-top:3px;">Cost increases per purchase</div>
    </div>

    <div class="panel">
      <h3>TECH UPGRADES</h3>
      <div class="shop-grid">
        <button class="btn tech-btn" onmouseenter="showTechTooltip('dmg', this)" onmouseleave="hideTooltip()" onclick="buyTech('dmg')"><span>DMG++</span><span id="cost_dmg">100</span></button>
        <button class="btn tech-btn" onmouseenter="showTechTooltip('range', this)" onmouseleave="hideTooltip()" onclick="buyTech('range')"><span>RNG++</span><span id="cost_range">100</span></button>
        <button class="btn tech-btn" onmouseenter="showTechTooltip('spd', this)" onmouseleave="hideTooltip()" onclick="buyTech('spd')"><span>SPD++</span><span id="cost_spd">100</span></button>
        <button class="btn tech-btn" onmouseenter="showTechTooltip('life', this)" onmouseleave="hideTooltip()" onclick="buyTech('life')"><span>REPAIR</span><span id="cost_life">50</span></button>
      </div>
    </div>

    <div class="panel grow">
      <h3>ARTIFACTS</h3>
      <div id="artifacts"></div>
    </div>
  </div>

  <div id="modalOverlay" class="hidden">
    <h2 id="modalTitle" style="color:white;text-shadow:0 0 10px
      var(--accent);"></h2>
    <div id="modalSubtitle" style="color:#aaa;"></div>
    <div id="draftStats" class="stats-box"></div>
    <div class="card-container" id="cards"></div>
  </div>
</div>

<script>
/* --- DATA --- */
// STARTERS
const STARTERS = [
  {name:'HYPER BEAM', desc:'Beam Tower DMG x3', fn: g=>{ const t=TOWERS.find(x=>x.id==='beam');
    t.dmg*=3; t.color='#fff'; t.unlocked=true; }},
  {name:'TREASURE HUNTER', desc:'Mythic Chance x5 (2.0%)', fn: g=>g.perks.mythicChance=0.02},
  {name:'FORTRESS', desc:'Start with 50 Integrity', fn: g=>{ g.maxLife=50;
    g.life=50; }},
  {name:'TYCOON', desc:'Start with 400 Credits', fn: g=>g.gold=400},
  {name:'VETERAN', desc:'Start with Lv.3 Laser', fn: g=>{
      const t = new Tower(5, 5, TOWERS[0], 3);
      g.gold += 150; g.globalMult.dmg += 0.2;
      g.towers.push(t);
  }},
  {name:'SNIPER ELITE', desc:'Unlock Sniper & Range +20%', fn: g=>{
      TOWERS.find(x=>x.id==='sniper').unlocked=true;
      g.globalMult.range+=0.2;
  }},
  {name:'GAMBLER', desc:'Start Gold: 100-800', fn: g=>{ g.gold = 100 + Math.floor(Math.random()*701);
    }},
  {name:'OVERCLOCK', desc:'SPD +30%, Range -10%', fn: g=>{ g.globalMult.spd+=0.3; g.globalMult.range-=0.1;
    }},
  {name:'MINIMALIST', desc:'DMG +50%, Integrity = 1', fn: g=>{ g.globalMult.dmg+=0.5; g.maxLife=1; g.life=1;
    }},
  {name:'ENGINEER', desc:'All Tech Costs -30%', fn: g=>{
      Object.keys(g.techCost).forEach(k => g.techCost[k] = Math.floor(g.techCost[k]*0.7));
    }}
];

const SKILL_TREES = {
  "nexus_core": {
    "name": "Nexus Core",
    "skills": [
      { id:"core_life_1", name:"Base Integrity +5", desc:"Base Integrity +5", cost:5, effects:{baseLife:5}, prerequisites:[] },
      { id:"core_gold_1", name:"Start Gold +30", desc:"Start Gold +30", cost:5, effects:{startGold:30}, prerequisites:[] },
      { id:"core_interest_1", name:"Interest Cap +10", desc:"Interest Cap +10 (Uncapped in v19)", cost:5, effects:{interestCap:10}, prerequisites:[] },
      { id:"core_tech_1", name:"Tech Cost -5%", desc:"Tech Cost -5%", cost:5, effects:{techDiscount:0.05}, prerequisites:[] },
      { id:"core_wave_gold", name:"Wave Gold +1",
        desc:"+1 Gold per wave", cost:5, effects:{waveStartGold:1}, prerequisites:[] },
      { id:"core_global_dmg", name:"Global DMG +3%", desc:"All Tower DMG +3%", cost:12, effects:{globalDmg:0.03}, prerequisites:["core_life_1"] },
      { id:"core_global_range", name:"Global RNG +3%", desc:"All Tower Range +3%", cost:12, effects:{globalRange:0.03}, prerequisites:["core_gold_1"] },
      { id:"core_global_spd", name:"Global SPD +3%", desc:"All Tower SPD +3%", cost:12, effects:{globalSpd:0.03}, prerequisites:["core_interest_1"] },
      { id:"core_merge_bonus", name:"Merge Bonus +10%", desc:"Synthesis bonus +10%", cost:12, effects:{mergeBonus:0.10}, prerequisites:["core_tech_1"] },
      { id:"core_cf_gain", name:"CF Gain +1", desc:"+1 CF on Wave Clear", cost:12, effects:{cfGain:1}, prerequisites:["core_wave_gold"] },
      { id:"core_dmg_big", name:"Global DMG +8%", desc:"All Tower DMG +8%", cost:25, effects:{globalDmg:0.08}, prerequisites:["core_global_dmg"] },
      { id:"core_crit_small", name:"Crit Chance +2%", desc:"Global Crit +2%", cost:25, effects:{crit:0.02}, prerequisites:["core_global_range"] },
      { id:"core_explode_small", name:"Explode Dmg +10%", desc:"Explode DMG +10%", cost:25, effects:{explode:0.10}, prerequisites:["core_global_spd"] },
      { id:"core_laser_width", name:"Laser Width +10%", desc:"Beam Width +10%", cost:25, effects:{laserWidth:0.10}, prerequisites:["core_merge_bonus"] },
      { id:"core_start_boost", name:"Start Boost +2s", desc:"Wave Start Haste +2s", cost:25, effects:{startBoost:2}, prerequisites:["core_cf_gain"] },
      { id:"core_max_life_big", name:"Max Integrity +10", desc:"Base Integrity +10", cost:40, effects:{maxLife:10},
        prerequisites:["core_dmg_big"] },
      { id:"core_start_gold_big", name:"Start Gold +100", desc:"Start Gold +100", cost:40, effects:{startGold:100}, prerequisites:["core_crit_small"] },
      { id:"core_easy_start", name:"Easy Start", desc:"Wave 1-3 Enemy HP -20%", cost:40, effects:{earlyEasy:true}, prerequisites:["core_explode_small"] },
      { id:"core_random_buff", name:"Random Wave Buff", desc:"Random buff per wave", cost:40, effects:{randomWaveBuff:true}, prerequisites:["core_laser_width"] }
    ]
  },
  "artifact_mastery": {
    "name": "Artifact Mastery",
    "skills": [
      { id:"art_slot_1", name:"Artifact Slots +3", desc:"Inventory +3", cost:6, effects:{artifactSlot:3}, prerequisites:[] },
      { id:"art_common_down", name:"Less Common",
        desc:"Common Chance -5%", cost:6, effects:{rarityCommon:-0.05}, prerequisites:[] },
      { id:"art_draft_plus", name:"Draft Options +1", desc:"Draft Choice +1", cost:12, effects:{draftChoices:1}, prerequisites:["art_slot_1"] },
      { id:"art_uncommon_up", name:"More Uncommon", desc:"Uncommon Chance +5%", cost:12, effects:{rarityUncommon:0.05}, prerequisites:["art_common_down"] },
      { id:"art_merge_bonus_perm", name:"Perm Merge Bonus", desc:"Merge grants +1% DMG", cost:12, effects:{mergePermanentDmg:0.01}, prerequisites:["art_slot_1"] },
      { id:"art_rare_up", name:"More Rare", desc:"Rare Chance +5%", cost:20, effects:{rarityRare:0.05}, prerequisites:["art_draft_plus"] },
      { id:"art_mythic_chance_plus", name:"Mythic Chance +", desc:"Mythic +0.05%", cost:20, effects:{mythicChance:0.0005}, prerequisites:["art_uncommon_up"] },
      { id:"art_merge_value", name:"Merge Value +5%",
        desc:"Upgrade Value +5%", cost:20, effects:{mergeValueBoost:0.05}, prerequisites:["art_merge_bonus_perm"] },
      { id:"art_bp_chance", name:"Blueprint +20%", desc:"BP Drop Rate +20%", cost:40, effects:{blueprintChance:0.20}, prerequisites:["art_rare_up"] },
      { id:"art_mythic_plus_big", name:"Mythic Chance ++", desc:"Mythic +0.1%", cost:40, effects:{mythicChance:0.001}, prerequisites:["art_mythic_chance_plus"] }
    ]
  },
  "weapon_system": {
    "name": "Weapon System",
    "skills": [
      { id:"laser_pierce_1", name:"Laser Pierce +1", desc:"Laser Pierce +1", cost:6, effects:{laserPierce:1}, prerequisites:[] },
      { id:"laser_dmg_1", name:"Laser DMG +5%", desc:"Laser DMG +5%", cost:6, effects:{laserDmg:0.05}, prerequisites:[] },
      {
        id:"laser_range", name:"Laser Range +10%", desc:"Laser Range +10%", cost:12, effects:{laserRange:0.10}, prerequisites:["laser_pierce_1"] },
      { id:"laser_mark", name:"Laser Marking", desc:"Hits amplify dmg", cost:22, effects:{laserMark:true}, prerequisites:["laser_range"] },
      { id:"beam_dmg_1", name:"Beam DMG +10%", desc:"Beam DMG +10%", cost:8, effects:{beamDmg:0.10}, prerequisites:[] },
      { id:"beam_cool", name:"Beam CD -10%", desc:"Cooldown -10%", cost:15, effects:{beamCd:-0.10}, prerequisites:["beam_dmg_1"] },
      { id:"beam_aoe", name:"Beam Shock", desc:"Beam deals AOE", cost:15, effects:{beamShockAoe:true}, prerequisites:["beam_dmg_1"] },
      { id:"blaster_prox", name:"Blaster Prox +20%", desc:"Prox bonus +20%", cost:8, effects:{blasterProx:0.20}, prerequisites:[] },
      { id:"blaster_slow",
        name:"Blaster Slow", desc:"Hits slow 10%", cost:12, effects:{blasterSlow:0.10}, prerequisites:["blaster_prox"] },
      { id:"blaster_shockwave", name:"Shockwave", desc:"50% chance shock", cost:20, effects:{blasterShock:0.5}, prerequisites:["blaster_slow"] },
      { id:"sniper_crit", name:"Sniper Crit +4%", desc:"Crit Chance +4%", cost:6, effects:{sniperCrit:0.04}, prerequisites:[] },
      { id:"sniper_range", name:"Sniper RNG +15%", desc:"Range +15%", cost:12, effects:{sniperRange:0.15}, prerequisites:["sniper_crit"] },
      { id:"sniper_pierce", name:"Sniper Pierce", desc:"Pierce +1", cost:20, effects:{sniperPierce:1}, prerequisites:["sniper_range"] },
      { id:"rocket_aoe", name:"Rocket Radius +10%", desc:"AOE +10%", cost:8, effects:{rocketAoe:0.10}, prerequisites:[] },
      { id:"rocket_speed", name:"Rocket Speed +20%", desc:"Speed +20%",
        cost:15, effects:{rocketSpeed:0.20}, prerequisites:["rocket_aoe"] },
      { id:"rocket_split", name:"Split Rocket", desc:"Splits on fire", cost:25, effects:{rocketSplit:true}, prerequisites:["rocket_speed"] },
      { id:"railgun_dmg", name:"Railgun DMG +10%", desc:"DMG +10%", cost:10, effects:{railgunDmg:0.10}, prerequisites:[] },
      { id:"railgun_pierce", name:"Railgun Pierce +3", desc:"Pierce +3", cost:10, effects:{railgunPierce:3}, prerequisites:["railgun_dmg"] },
      { id:"railgun_vuln", name:"Vulnerability", desc:"Hits debuff 10%", cost:25, effects:{railgunVuln:0.10}, prerequisites:["railgun_pierce"] }
    ]
  },
  "paradox": {
    "name": "Paradox",
    "skills": [
      { id:"para_doublehit", name:"Quantum Doubler", desc:"25% chance double hit", cost:50,
        effects:{doubleHit:0.25}, prerequisites:[] },
      { id:"para_neural", name:"Neural Overdrive", desc:"SPD x2 but 25% Miss", cost:50, effects:{overdrive:true}, prerequisites:[] },
      { id:"para_gravity", name:"Gravity Break", desc:"Enemy -40% SPD, +30% HP", cost:80, effects:{enemySlow:0.40, enemyHpBoost:0.30}, prerequisites:["para_doublehit"] },
      { id:"para_midas", name:"Midas Protocol", desc:"Crits drop +1 Gold", cost:80, effects:{midas:true}, prerequisites:["para_neural"] },
      { id:"para_infinite_bp", name:"Infinite BP", desc:"All Weapons Unlocked", cost:150, effects:{unlockAll:true}, prerequisites:["para_gravity"] },
      { id:"para_tier_plus", name:"Tier +1", desc:"Start Tier +1", cost:150, effects:{tierPlus:1}, prerequisites:["para_midas"] }
    ]
  }
};
/* --- SYSTEM --- */
const GRID_W = 16, GRID_H = 10;
let TILE, game, mousePos, selectDef, selectedTower = null;
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

let saveData = { cf: 0, unlocked: [], seenVersion: null };
let activeTab = 'nexus_core';
let animationId = null;
const CURRENT_VERSION = "0.2.1"; // Updated Version

/* --- GAME DEFINITIONS --- */
const RARITIES = ['common', 'uncommon', 'rare', 'epic', 'legendary', 'mythic'];
const RARITY_COLORS = {common:'#b0b0b0', uncommon:'#44ff44', rare:'#2e8cff', epic:'#a335ee', legendary:'#ffaa00', mythic:'#ff0055'};

const BASE_TOWERS = [
  {id:'laser', name:'LASER', cost:30, dmg:4, fire:0.2, range:4.0, color:'#2ee6ff', type:'pierce', pierce:3, unlocked:true},
  {id:'beam', name:'H.BEAM', cost:70, dmg:20, fire:1.2, range:5.5, color:'#7b6bff', type:'single', unlocked:false},
  {id:'blaster', name:'BLASTER', cost:100, dmg:10, fire:0.8, range:3.0, color:'#ff4d4d', type:'aoe_prox', unlocked:false},
  {id:'sniper', name:'SNIPER', cost:150, dmg:80, fire:0, range:12.0, color:'#00ff88', type:'charge_shot', unlocked:false},
  {id:'rocket', name:'ROCKET', cost:250, dmg:60, fire:2.4, range:4.5, color:'#ffaa00', type:'aoe', unlocked:false},
  {id:'railgun', name:'RAILGUN', cost:400, dmg:120, fire:4.0, range:14.0, color:'#ff00ff', type:'pierce', pierce:10, unlocked:false},
  {id:'booster', name:'AMPLIFIER', cost:300, dmg:0, fire:0, range:0, color:'#8888ff', type:'support', unlocked:false}
];
let TOWERS = JSON.parse(JSON.stringify(BASE_TOWERS));

// EVENTS (EXPANDED)
const WAVE_EVENTS = [
    {id:'armor_surge', name:'ARMOR SURGE', desc:'All enemies gain +5 Armor.', duration:5, type:'nerf', onStart: e => e.armor += 5, onEnd: e => e.armor -= 5},
    {id:'night_vision', name:'NIGHT VISION', desc:'Reduced vision. Sniper towers are unaffected.', duration:5, type:'nerf', special:'night_vision'},
    {id:'magnetic_distortion', name:'MAGNETIC FIELD', desc:'Enemies periodically shift positions.', duration:4, type:'mixed', special:'magnetic_distortion'},
    {id:'anomaly_rift', name:'ANOMALY RIFT', desc:'Enemies have a 50% chance to evade non-piercing attacks.', duration:3, type:'nerf', special:'anomaly_rift'},
    {id:'titan_rage', name:'TITAN RAGE', desc:'The next Boss will evolve mid-fight, healing and gaining HP.', duration:1, type:'nerf', special:'titan_rage'},
    {id:'hyper_rift', name:'HYPER RIFT', desc:'Enemies are 50% faster, but drop 3x Credits.', duration:3, type:'mixed', onStart: e => {e.speed *= 1.5}, onEnd: e => {e.speed /= 1.5}, special:'hyper_bounty'},
    {id:'mythic_res', name:'MYTHIC RESONANCE', desc:'Mythic Artifact chance is greatly increased for 3 waves.', duration:3, type:'buff', special:'mythic_chance_up'},
    {id:'gold_rush', name:'GOLD RUSH', desc:'All Credit drops are doubled.', duration:4, type:'buff', special:'gold_rush'}
];

// ARTIFACTS
const BASE_ARTIFACTS = [
  {id:'atk', name:'Core', desc:'DMG +[X]%', val:[5, 10, 18, 30, 45], fn:(g,v)=>g.globalMult.dmg+=v/100}, // Nerfed
  {id:'spd', name:'Servo', desc:'SPD +[X]%', val:[5, 10, 18, 30, 45], fn:(g,v)=>g.globalMult.spd+=v/100}, // Nerfed
  {id:'rng', name:'Lens', desc:'RNG +[X]%', val:[8, 15, 25, 40, 60], fn:(g,v)=>g.globalMult.range+=v/100}, // Nerfed
  {id:'eco', name:'Chip', desc:'Interest +[X]%', val:[0.1, 0.2, 0.3, 0.4, 0.5], fn:(g,v)=>g.perks.interest+=v/100},
  {id:'crit', name:'Aim', desc:'Crit +[X]%', val:[2, 4, 7, 12, 20], fn:(g,v)=>g.perks.crit+=v/100}, // Nerfed
  {id:'boom', name:'Powder', desc:'Explode [X]% DMG', val:[8, 15, 25, 40, 70], fn:(g,v)=>g.perks.explodeDmg+=v/100}, // Nerfed
  {id:'coil', name:'Overload', desc:'Crit DMG +[X]%', val:[25, 40, 60, 90, 140], fn:(g,v)=>g.perks.critMult += v/100}, // Nerfed
  {id:'armor', name:'Hardlight', desc:'Max Integrity +[X]', val:[1, 2, 4, 6, 10], fn:(g,v)=>{ g.maxLife += v; g.life += v; }},
  {id:'burst', name:'Q.Charge', desc:'Start Burst +[X]s', val:[1, 2, 3, 4, 5], fn:(g,v)=>g.perks.startBoost += v}
];
const UNIQUE_ARTIFACTS = [
  {id:'scope', name:'Assassin Scope', rarityIdx: 2, desc:'Deal up to +30% DMG to full HP enemies and +20% to enemies below 20% HP.', fn:g=>g.perks.assassinScope=true},
  {id:'echo', name:'Echo Round', rarityIdx: 2, desc:'Attacks trigger a secondary, 50% damage hit 0.25s later.', fn:g=>g.perks.echoRound=true}
];
let ARTIFACT_TYPES = [...BASE_ARTIFACTS];

const MYTHICS = [
  {id:'god', name:'DEUS EX', rarity:'mythic', desc:'MYTHIC: All Towers Tier +1 Stats', fn: g=>g.globalMult.tierBonus+=1},
  {id:'midas', name:'MIDAS TOUCH', rarity:'mythic', desc:'MYTHIC: +1 Gold per Hit', fn: g=>g.perks.goldPerHit+=1},
  {id:'time', name:'CHRONO SHIFT', rarity:'mythic', desc:'MYTHIC: Enemies 30% Slower', fn: g=>g.perks.slowMult=0.7},
  {id:'rot', name:'CORRUPTION CORE', rarity:'mythic', desc:'MYTHIC: Kill reduces nearby Armor', fn: g=>g.perks.debuffArmor=0.1},
  {id:'risk', name:'VOID CONTRACT', rarity:'mythic', desc:'MYTHIC: HP=1, DMG x4 (Risky)', fn: g=>{ g.maxLife=1;
    g.life=1; g.globalMult.dmg+=3; }},
  {id:'copy', name:'QUANTUM DOUBLER', rarity:'mythic', desc:'MYTHIC: 50% Chance Double Hit', fn: g=>g.perks.doubleHit=0.5},
  {id:'fort', name:'FORTRESS ENGINE', rarity:'mythic', desc:'MYTHIC: Integrity x3', fn: g=>{ g.maxLife*=3;
    g.life*=3; }}
];

/* --- SAVE SYSTEM --- */
function loadSave() {
  const s = localStorage.getItem('hyperRogueV0_2_1'); // Updated Save Key
  if(s) {
    try {
      const d = JSON.parse(s);
      saveData.cf = d.cf || 0;
      saveData.unlocked = d.unlocked || [];
      saveData.seenVersion = d.seenVersion || null;
    } catch(e) { console.error("Save Corrupt");
    }
  }
  updateUpgradeUI();
  checkNews();
}
function saveGame() {
  localStorage.setItem('hyperRogueV0_2_1', JSON.stringify(saveData)); // Updated Save Key
  updateUpgradeUI();
}

/* --- SECRET CODE SYSTEM --- */
document.getElementById('secretCode').addEventListener('keydown', function(e) {
    if (e.key === 'Enter') {
        const input = document.getElementById('secretCode');
        if(input.value === 'manifest') {
            saveData.cf += 50;
            saveGame();
            alert("SECRET CODE ACCEPTED: +50 CF");
            input.value = '';
        } else if(input.value === 'devalpha') {
            saveData.cf += 2048;
            saveGame();
            alert("DEV CODE ACCEPTED: +2048 CF");
            input.value = '';
        }
        input.blur();
    }
});


/* --- NEWS SYSTEM --- */
function checkNews() {
    if(saveData.seenVersion !== CURRENT_VERSION) {
        openNews();
    }
}
function closeNews() {
    document.getElementById('newsOverlay').classList.add('hidden');
    if(saveData.seenVersion !== CURRENT_VERSION) {
        saveData.seenVersion = CURRENT_VERSION;
        saveGame();
    }
}
function openNews() {
    document.getElementById('newsOverlay').classList.remove('hidden');
}

/* --- UPGRADE UI --- */
function switchTab(t) {
  activeTab = t;
  document.querySelectorAll('.tab-btn').forEach(b => {
    b.classList.toggle('active', b.innerText.includes(SKILL_TREES[t].name.split(' ')[0].toUpperCase()));
  });
  updateUpgradeUI();
}
function updateUpgradeUI() {
  document.getElementById('cfVal').innerText = saveData.cf;
  const container = document.getElementById('treeView');
  container.innerHTML = '';
  const tree = SKILL_TREES[activeTab];
  if(!tree) return;
  tree.skills.forEach(skill => {
    const isUnlocked = saveData.unlocked.includes(skill.id);
    const canAfford = saveData.cf >= skill.cost;
    const reqsMet = skill.prerequisites.length === 0 || skill.prerequisites.every(req => saveData.unlocked.includes(req));
    const isBuyable = !isUnlocked && reqsMet && canAfford;
    const isLocked = !isUnlocked && !reqsMet;

    const el = document.createElement('div');
    el.className = `skill-node ${isUnlocked ? 'unlocked' : ''} ${isBuyable ? 'affordable' : ''}`;
    if(isLocked) el.style.opacity = '0.3';

    el.innerHTML = `
      <div class="skill-name">${skill.name}</div>

      <div class="skill-desc">${skill.desc}</div>
      <div class="skill-cost">${isUnlocked ? 'ACQUIRED' : (skill.cost + ' CF')}</div>
      ${isUnlocked ? '<div class="skill-owned">✔</div>' : ''}
    `;
    if(isBuyable) el.onclick = () => purchaseSkill(skill);
    container.appendChild(el);
  });
}
function purchaseSkill(skill) {
  if(saveData.cf >= skill.cost && !saveData.unlocked.includes(skill.id)) {
    saveData.cf -= skill.cost;
    saveData.unlocked.push(skill.id);
    saveGame();
  }
}

/* --- GAME STATE --- */
function startGameFromMenu() {
  document.getElementById('upgradeScreen').classList.add('hidden');
  document.getElementById('gameOverOverlay').classList.add('hidden');
  document.getElementById('gameScreen').classList.remove('hidden');

  initGame();
  resize();
  showStarterScreen();
}

function returnToMenu() {
  document.getElementById('upgradeScreen').classList.remove('hidden');
  document.getElementById('gameOverOverlay').classList.add('hidden');
  document.getElementById('gameScreen').classList.add('hidden');
  document.getElementById('pauseOverlay').classList.add('hidden');
  document.getElementById('modalOverlay').classList.add('hidden');
  document.getElementById('newsOverlay').classList.add('hidden');
  document.getElementById('flashOverlay').classList.add('hidden');

  hideTooltip();
  updateUpgradeUI();
  game = null;
}

/* --- PAUSE, SPEED, RETIRE --- */
function togglePause() {
  if(!game || game.state === 'idle' || game.state === 'over') return;
  game.paused = !game.paused;
  const overlay = document.getElementById('pauseOverlay');
  if(game.paused) {
      renderCurrentStats('pauseStats');
      overlay.classList.remove('hidden');
  } else overlay.classList.add('hidden');
}
function setSpeed(s) {
    if(!game) return;
    game.speed = s;
    document.querySelectorAll('.spd-btn').forEach(b => b.classList.remove('active'));
    if(s===1) document.getElementById('btnSpd1').classList.add('active');
    if(s===1.5) document.getElementById('btnSpd15').classList.add('active');
    if(s===2) document.getElementById('btnSpd2').classList.add('active');
}
function retireGame() {
  if(!game) return;
  const cfEarned = Math.round(game.wave * 0.25 * (1 + (game.perks.cfGain||0))); // Apply CF Gain
  saveData.cf += cfEarned;
  saveGame();
  log(`RETIRED. EARNED ${cfEarned} CF.`);
  returnToMenu();
}

/* --- STATS DISPLAY --- */
function renderCurrentStats(containerId) {
    const el = document.getElementById(containerId);
    if(!el || !game) return;
    const p = (v) => (v > 0 ? "+" : "") + Math.round(v*100) + "%";
    let interestRate = 0.03 + game.perks.interest;
    const s = [
        {l:"Global DMG", v:p(game.globalMult.dmg)},
        {l:"Global RNG", v:p(game.globalMult.range)},
        {l:"Global SPD", v:p(game.globalMult.spd)},
        {l:"Crit Chance", v:Math.round(game.perks.crit*100) + "%"},
        {l:"Crit Mult", v:"x" + game.perks.critMult.toFixed(1)},
        {l:"Explode DMG", v:p(game.perks.explodeDmg)},
        {l:"Interest Rate", v:(interestRate*100).toFixed(1) + "%"},
        {l:"Start Gold", v:"+"+game.perks.waveStartGold},
        {l:"Gold/Hit", v:"+"+game.perks.goldPerHit},
        {l:"Mythic Chance", v:(game.perks.mythicChance*100).toFixed(2)+"%"},
        {l:"Start Boost", v:game.perks.startBoost+"s"},
        {l:"Double Hit", v:Math.round(game.perks.doubleHit*100)+"%"}
    ];
    let html = "";
    s.forEach(i => {
        html += `<div class="stat-item"><span class="stat-name">${i.l}</span><span class="stat-val">${i.v}</span></div>`;
    });
    el.innerHTML = html;
}

/* --- TOOLTIP LOGIC --- */
const tooltipEl = document.getElementById('globalTooltip');
function showTooltip(e, text) {
    tooltipEl.innerHTML = text;
    tooltipEl.style.display = 'block';
    moveTooltip(e);
}
function hideTooltip() {
    tooltipEl.style.display = 'none';
}
function moveTooltip(e) {
    if(tooltipEl.style.display === 'block') {
        const x = e.clientX + 15;
        const y = e.clientY + 15;
        const rect = tooltipEl.getBoundingClientRect();
        let left = x; let top = y;
        if(left + rect.width > window.innerWidth) left = x - rect.width - 30;
        if(top + rect.height > window.innerHeight) top = y - rect.height - 30;
        tooltipEl.style.left = left + 'px';
        tooltipEl.style.top = top + 'px';
    }
}
function showTechTooltip(type, el) {
    if(!game) return;
    let txt = "";
    if(type==='dmg') txt = `DMG Multiplier: x${(1+game.globalMult.dmg).toFixed(2)}`;
    else if(type==='range') txt = `Range Multiplier: x${(1+game.globalMult.range).toFixed(2)}`;
    else if(type==='spd') txt = `Speed Multiplier: x${(1+game.globalMult.spd).toFixed(2)}`;
    else if(type==='life') txt = `Restore Integrity (+5)\nMax: ${game.maxLife}`;
    txt += `\n<span style='color:var(--legend)'>Next Cost: ${game.techCost[type]} CR</span>`;

    showTooltip({clientX: el.getBoundingClientRect().right, clientY: el.getBoundingClientRect().top}, txt);
}
window.addEventListener('mousemove', moveTooltip);

/* --- GAME SYSTEM --- */
function initGame() {
  if(animationId) cancelAnimationFrame(animationId);
  resetGame();
  loop();
}

function resetGame() {
  TOWERS = JSON.parse(JSON.stringify(BASE_TOWERS));
  ARTIFACT_TYPES = [...BASE_ARTIFACTS];
  document.getElementById('artifacts').innerHTML = '';
  document.getElementById('logContent').innerHTML = '';
  document.getElementById('dpsList').innerHTML = '';
  document.getElementById('eventHud').innerHTML = '';

  game = {
    gold: 80, life: 20, maxLife: 20, wave: 0, speed: 1.0,
    state: 'idle', paused: false,
    path: generatePath(),
    blocked: [],
    towers: [], enemies: [], particles: [], lasers: [], dmgTexts: [],
    globalMult: { dmg:0, range:0, spd:0, tierBonus:0 },
    perks: {
        interest:0, crit:0, critMult:2.0, explodeDmg:0,
        startHpMult:1, goldPerHit:0, mythicChance: 0.004, slowMult:1,
        debuffArmor:0, doubleHit:0, startBoost:0, interestCap:99999,
        cfGain:0, waveStartGold:0, blueprintChance:0.15,
        overdrive: false, midas: false,
        assassinScope: false, echoRound: false
    },
    techCost: { dmg:100, range:100, spd:100, life:50 },
    towerCounts: {},
    artifacts: [],
    mythicHistory: new Set(),
    activeEvents: [],
    lifeAtWaveStart: 0,
    enemiesToSpawn: 0,
    enemiesSpawned: 0,
    spawnTimer: 0, spawnInterval: 0,
    waveStartTime: 0,
    dpsCurrent: {}, lastDpsUpdate: 0,
    augments: {},
    bossKillBonusWave: -1,
  };
  setSpeed(1);
  document.getElementById('nextWaveBtn').disabled = false;

  const flash = document.getElementById('flashOverlay');
  flash.classList.remove('flash-overlay');
  void flash.offsetWidth;
  flash.classList.add('hidden');

  document.getElementById('goldRushOverlay').classList.add('hidden');
  document.getElementById('retryOverlay').classList.add('hidden');
  TOWERS.forEach(t => { game.towerCounts[t.id] = 0; game.dpsCurrent[t.id] = 0; });
  generateObstacles();
  applyPermanentUpgrades();
  renderShop();
}

function showStarterScreen() {
    const pool = [...STARTERS];
    const choices = [];
    while(choices.length < 4 && pool.length > 0) {
        const idx = Math.floor(Math.random() * pool.length);
        choices.push(pool[idx]);
        pool.splice(idx, 1);
    }

    const modal = document.getElementById('modalOverlay');
    const container = document.getElementById('cards');
    document.getElementById('modalTitle').innerText = "INITIALIZE PROTOCOL";
    document.getElementById('modalSubtitle').innerText = "Select Starter Bonus";
    container.innerHTML = '';
    modal.classList.remove('hidden');
    choices.forEach(s => {
        const el = document.createElement('div');
        el.className = 'card starter';
        el.innerHTML = `<h4 style="font-size:0.9rem">${s.name}</h4><p>${s.desc}</p>`;
        el.onclick = () => {
            s.fn(game);
            modal.classList.add('hidden');
            log(`PROTOCOL ACTIVE: ${s.name}`);
            updateHUD();
            renderShop();
            draw();
        };
        container.appendChild(el);
    });
}

function applyPermanentUpgrades() {
  const allSkills = [
    ...SKILL_TREES.nexus_core.skills,
    ...SKILL_TREES.artifact_mastery.skills,
    ...SKILL_TREES.weapon_system.skills,
    ...SKILL_TREES.paradox.skills
  ];
  saveData.unlocked.forEach(id => {
    const s = allSkills.find(x => x.id === id);
    if(!s) return;
    const fx = s.effects;

    if(fx.baseLife) { game.maxLife += fx.baseLife; game.life = game.maxLife; }
    if(fx.startGold) game.gold += fx.startGold;
    if(fx.techDiscount) Object.keys(game.techCost).forEach(k => game.techCost[k] = Math.floor(game.techCost[k] * (1-fx.techDiscount)));
    if(fx.waveStartGold) game.perks.waveStartGold += fx.waveStartGold;
    if(fx.cfGain) game.perks.cfGain += fx.cfGain;
    if(fx.startBoost) game.perks.startBoost += fx.startBoost;
    if(fx.maxLife) { game.maxLife += fx.maxLife; game.life = game.maxLife; }
    if(fx.earlyEasy) game.perks.earlyEasy = true;
    if(fx.randomWaveBuff) game.perks.randomWaveBuff = true;

    if(fx.globalDmg) game.globalMult.dmg += fx.globalDmg;
    if(fx.globalRange) game.globalMult.range += fx.globalRange;
    if(fx.globalSpd) game.globalMult.spd += fx.globalSpd;
    if(fx.tierBonus) game.globalMult.tierBonus += fx.tierBonus;
    if(fx.tierPlus) game.globalMult.tierBonus += fx.tierPlus;

    if(fx.unlockAll) TOWERS.forEach(t => t.unlocked = true);
    if(fx.laserPierce) modifyTower('laser', t => t.pierce += fx.laserPierce);
    if(fx.laserDmg) modifyTower('laser', t => t.dmg *= (1+fx.laserDmg));
    if(fx.laserRange) modifyTower('laser', t => t.range *= (1+fx.laserRange));
    if(fx.laserMark) game.augments.laserMark = true;
    if(fx.beamDmg) modifyTower('beam', t => t.dmg *= (1+fx.beamDmg));
    if(fx.beamCd) modifyTower('beam', t => t.fire *= (1+fx.beamCd));
    if(fx.beamShockAoe) game.augments.beamShockAoe = true;
    if(fx.beamIgnoreArmor) game.augments.beamIgnoreArmor = true;

    if(fx.blasterProx) game.augments.blasterProx = fx.blasterProx;
    if(fx.blasterAoe) game.augments.blasterAoe = fx.blasterAoe;
    if(fx.blasterSlow) game.augments.blasterSlow = true;
    if(fx.blasterShock) game.augments.blasterShock = true;
    if(fx.blasterAoeMult) game.augments.blasterAoeMult = fx.blasterAoeMult;

    if(fx.sniperCrit) game.perks.crit += fx.sniperCrit;
    if(fx.sniperDmg) modifyTower('sniper', t => t.dmg *= (1+fx.sniperDmg));
    if(fx.sniperRange) modifyTower('sniper', t => t.range *= (1+fx.sniperRange));
    if(fx.sniperPierce) modifyTower('sniper', t => { t.type='pierce'; t.pierce=1; });
    if(fx.sniperMaxHpDmg) game.augments.sniperMaxHpDmg = fx.sniperMaxHpDmg;
    if(fx.rocketAoe) game.augments.rocketAoe = fx.rocketAoe;
    if(fx.rocketDmg) modifyTower('rocket', t => t.dmg *= (1+fx.rocketDmg));
    if(fx.rocketSpeed) game.augments.rocketSpeed = fx.rocketSpeed;
    if(fx.rocketSplit) game.augments.rocketSplit = true;
    if(fx.railgunDmg) modifyTower('railgun', t => t.dmg *= (1+fx.railgunDmg));
    if(fx.railgunPierce) modifyTower('railgun', t => t.pierce += fx.railgunPierce);
    if(fx.railgunVuln) game.augments.railgunVuln = true;
    if(fx.doubleHit) game.perks.doubleHit += fx.doubleHit;
    if(fx.overdrive) game.perks.overdrive = true;
    if(fx.enemySlow) game.perks.enemySlow = fx.enemySlow;
    if(fx.enemyHpBoost) game.perks.enemyHpBoost = fx.enemyHpBoost;
    if(fx.midas) game.perks.midas = true;
  });
}
function modifyTower(id, fn) { const t=TOWERS.find(x=>x.id===id); if(t) fn(t); }

/* --- LOGIC CLASSES --- */
class Particle {
  constructor(x, y, color, speed=0.2, life=1.0) {
    this.x = x;
    this.y = y; this.color = color;
    this.vx = (Math.random()-0.5)*speed; this.vy = (Math.random()-0.5)*speed;
    this.life = life;
  }
  update() { this.x+=this.vx;
    this.y+=this.vy; this.life-=0.04; }
  draw(ctx, t) {
    ctx.globalAlpha = this.life; ctx.fillStyle = this.color;
    ctx.fillRect(this.x*t, this.y*t, t*0.15, t*0.15);
    ctx.globalAlpha = 1;
  }
}
class DamageText {
  constructor(x, y, text, color='#fff', isCrit=false, critLevel=0) {
    this.x = x;
    this.y = y; this.text = text; this.color = color; this.isCrit = isCrit;
    this.life = 1.0; this.vy = -0.01;
    this.critLevel = critLevel;
  }
  update() { this.y += this.vy; this.life -= 0.02;
  }
  draw(ctx, t) {
    ctx.globalAlpha = Math.max(0, this.life);
    ctx.fillStyle = this.color; ctx.strokeStyle = '#000';
    ctx.lineWidth = 2;
    let scale = this.isCrit ? 0.6 : 0.35;
    if(this.critLevel >= 3) scale = 0.9;
    ctx.font = "bold " + (t*scale) + "px sans-serif";
    ctx.strokeText(this.text, this.x*t, this.y*t);
    ctx.fillText(this.text, this.x*t, this.y*t);
    ctx.globalAlpha = 1;
  }
}
class Enemy {
  constructor(path, wave, type='normal', progressOverride=0) {
    this.path = path; this.type = type;
    const currentWave = Math.max(1, wave);
    let hpMult = 1.0;
    if(game.perks.earlyEasy && currentWave <= 3) hpMult = 0.8;
    if(game.perks.enemyHpBoost) hpMult += game.perks.enemyHpBoost;
    this.maxHp = Math.floor(15 * Math.pow(1.22, currentWave) * hpMult);
    if(game.perks.startHpMult) this.maxHp = Math.floor(this.maxHp * game.perks.startHpMult);
    this.speed = 1.0 + (currentWave * 0.04);
    if(game.perks.slowMult) this.speed *= game.perks.slowMult;
    if(game.perks.enemySlow) this.speed *= (1.0 - game.perks.enemySlow);

    this.shield = 0;
    this.armor = 0; this.regen = 0; this.debuffs = { slow:0, vuln:0, mark:0 };
    if (this.type === 'boss') {
        this.maxHp *= (6 + wave*0.1);
        this.speed *= 0.6;
        this.armor += Math.floor(wave / 5);
        this.canEvolve = game.activeEvents.some(e => e.special === 'titan_rage');
    }
    if (this.type === 'tank') { this.maxHp *= 6; this.speed *= 0.5; this.armor += 3; }
    if (this.type === 'elite') { this.maxHp *= 1.5; if(Math.random()<0.5) this.speed *= 1.3; else this.armor = 3; }
    if (this.type === 'phase') { this.speed *= 0.9; this.phaseCool = 0.5; }

    if (this.type === 'monolith') {
        this.maxHp *= 12;
        this.speed *= 0.2;
        progressOverride = Math.floor(path.length / 2) + Math.random() * 4 - 2;
    }

    this.hp = this.maxHp;
    this.progress = progressOverride;
    this.alive = true;
    this.pos = {x:0, y:0};
    this.visualPos = {x:0, y:0}; // For magnetic distortion

    const i = Math.floor(this.progress);
    if (i < this.path.length) {
        this.pos.x = this.path[i].x + 0.5;
        this.pos.y = this.path[i].y + 0.5;
        this.visualPos = {...this.pos};
    } else {
        this.alive = false;
    }
  }
  update(dt) {
    if(!this.alive) return;
    if(this.regen > 0 && this.hp < this.maxHp) this.hp += this.regen * dt;

    let actualSpeed = this.speed * (1.0 - this.debuffs.slow);
    const hyperRift = game.activeEvents.find(e=>e.special === 'hyper_bounty');
    if(hyperRift) actualSpeed *= 1.5;

    this.progress += actualSpeed * dt;
    const i = Math.floor(this.progress);
    if(i >= this.path.length-1) { this.alive=false; this.reached=true; return; }
    const t = this.progress - i;
    this.pos.x = this.path[i].x + (this.path[i+1].x - this.path[i].x)*t + 0.5;
    this.pos.y = this.path[i].y + (this.path[i+1].y - this.path[i].y)*t + 0.5;

    this.visualPos = {...this.pos};
    if (game.activeEvents.some(e=>e.special==='magnetic_distortion')) {
        this.visualPos.x += Math.sin(Date.now() / 100 + this.progress) * 0.2;
        this.visualPos.y += Math.cos(Date.now() / 100 + this.progress) * 0.2;
    }

    if(this.type === 'boss' && this.canEvolve && this.hp < this.maxHp * 0.5) {
        this.maxHp *= 1.25;
        this.hp = this.maxHp;
        this.canEvolve = false;
        spawnParticles(this.pos.x, this.pos.y, '#ff0000', 50, 3.0);
        log("BOSS HAS EVOLVED!");
    }
  }
  takeDmg(amt, isCrit=false, srcId='unknown', critLevel=0, options = {}) {
    if(!this.alive) return;
    const isAnomalyRift = game.activeEvents.some(e=>e.special==='anomaly_rift');
    if(isAnomalyRift && !options.isPiercing && Math.random() < 0.5) {
        game.dmgTexts.push(new DamageText(this.visualPos.x, this.visualPos.y - 0.5, "RIFT", "#aaa"));
        return;
    }

    if(game.perks.overdrive && Math.random() < 0.25) { game.dmgTexts.push(new DamageText(this.visualPos.x, this.visualPos.y - 0.5, "MISS", "#aaa"));
    return; }

    if(game.perks.assassinScope) {
        if(this.hp >= this.maxHp) amt *= 1.3;
        else if(this.hp <= this.maxHp * 0.2) amt *= 1.2;
    }

    let multiplier = 1.0 + this.debuffs.vuln + this.debuffs.mark;
    let finalDmg = Math.max(1, (amt * multiplier) - this.armor);
    this.hp -= finalDmg;
    if(srcId && game.dpsCurrent[srcId] !== undefined) game.dpsCurrent[srcId] += finalDmg;

    let goldGain = game.perks.goldPerHit;
    if(game.bossKillBonusWave === game.wave || game.activeEvents.some(e=>e.special==='gold_rush')) goldGain *= 2;
    if(goldGain > 0) game.gold += goldGain;

    let color = '#fff';
    if(isCrit) {
        if(critLevel === 1) color = '#ffd700';
        else if(critLevel === 2) color = '#ff8c00';
        else if(critLevel >= 3) color = '#ff0000';
    }
    game.dmgTexts.push(new DamageText(this.visualPos.x, this.visualPos.y - 0.5, Math.floor(finalDmg), color, isCrit, critLevel));
    if(game.perks.echoRound && srcId !== 'echo') {
        setTimeout(() => {
            if(this.alive) this.takeDmg(finalDmg * 0.5, false, 'echo');
        }, 250);
    }

    if(this.hp <= 0 && this.alive) {
      this.alive = false;
      this.killed = true; spawnParticles(this.pos.x, this.pos.y, '#ff4d4d', 5);

      if(this.type === 'boss') {
          grantBossReward();
          game.bossKillBonusWave = game.wave + 1;
          log("BOSS DESTROYED! GOLD RUSH ACTIVATED FOR NEXT WAVE!");
      }

      if(game.perks.midas && isCrit) game.gold += 1;
      if(game.perks.debuffArmor) {
         game.enemies.forEach(e => { if(e.alive && Math.hypot(e.pos.x-this.pos.x, e.pos.y-this.pos.y) < 3.0) { e.armor = Math.max(0, e.armor - 2); spawnParticles(e.pos.x, e.pos.y, '#550055', 3); }});
      }
      if(game.perks.explodeDmg > 0) {
        spawnParticles(this.pos.x, this.pos.y, '#ffa500', 8);
        const boomDmg = this.maxHp * game.perks.explodeDmg;
        game.enemies.forEach(e => { if(e.alive && Math.hypot(e.pos.x-this.pos.x, e.pos.y-this.pos.y) < 2.0) e.takeDmg(boomDmg, false, 'explode'); });
      }
    }
  }
}

class Tower {
  constructor(x, y, def, tier=1) {
      this.x = x;
      this.y = y; this.def = def; this.tier = tier;
      this.cool = 0; this.angle = 0;
      this.charge = 0;
  }
  getNeighborBuffs() {
    let buffDmg = 1.0; let buffSpd = 1.0;
    for(let dx=-1; dx<=1; dx++) {
        for(let dy=-1; dy<=1; dy++) {
            if(dx===0 && dy===0) continue;
            const neighbor = game.towers.find(t => t.x === this.x+dx && t.y === this.y+dy);
            if(neighbor && neighbor.def.id === 'booster') { buffDmg *= 1.2; buffSpd *= 1.2;
            }
        }
    }
    return {dmg: buffDmg, spd: buffSpd};
  }

  update(dt, enemies) {
    if(this.def.type === 'support') return;
    const buffs = this.getNeighborBuffs();
    let spdMult = (1 + game.globalMult.spd) * buffs.spd;
    if(game.perks.overdrive) spdMult *= 2;
    let boostTime = game.perks.startBoost;
    if(saveData.unlocked.includes('core_start_boost')) boostTime += 2;
    if(boostTime > 0 && game.waveStartTime && Date.now() - game.waveStartTime < boostTime * 1000) spdMult *= 2;

    let isNightVision = game.activeEvents.some(e=>e.special==='night_vision');
    let range = this.def.range * (1 + game.globalMult.range + (this.tier-1)*0.1);
    if(isNightVision && this.def.id !== 'sniper') range *= 0.6;

    let effectiveTier = this.tier + (game.globalMult.tierBonus || 0);
    let tierMult = Math.pow(1.5, effectiveTier - 1);
    let dmg = this.def.dmg * (1 + game.globalMult.dmg) * tierMult * buffs.dmg;

    let isCrit = false;
    let critLevel = 0;
    let critChance = game.perks.crit;
    let critMult = game.perks.critMult;
    while(critChance > 0) {
        if(Math.random() < critChance) {
            isCrit = true;
            critLevel++;
        }
        critChance -= 1.0;
    }
    if(isCrit) dmg *= (1 + (critLevel * (critMult - 1)));

    /* --- SNIPER SPECIAL LOGIC (CHARGE) --- */
    if (this.def.type === 'charge_shot') {
        const chargeTime = 4.0 / (1 + (spdMult - 1) * 0.5);
        const targets = enemies.filter(e => e.alive && Math.hypot(e.visualPos.x-(this.x+0.5), e.visualPos.y-(this.y+0.5)) < range);
        if (targets.length > 0) {
            targets.sort((a,b) => b.progress - a.progress);
            const target = targets[0];
            this.angle = Math.atan2(target.visualPos.y-(this.y+0.5), target.visualPos.x-(this.x+0.5));
            this.targetRef = target;

            this.charge += dt;
            if(this.charge >= chargeTime) {
                const chargeMult = 3.0 + (this.tier * 0.5);
                let finalDmg = dmg * chargeMult;
                this.applyHit(target, finalDmg, isCrit, critLevel, {isPiercing:true});
                game.lasers.push({
                    x1:this.x+0.5, y1:this.y+0.5, x2:target.visualPos.x, y2:target.visualPos.y,
                    color: isCrit ? '#fff' : '#00ff88', width: 3, life: 10
                });
                spawnParticles(this.x+0.5, this.y+0.5, '#00ff88', 10);
                this.charge = 0;
            }
        } else {
            this.charge = Math.max(0, this.charge - dt*2);
            this.targetRef = null;
        }
        return;
    }

    /* --- STANDARD FIRE --- */
    let fireRate = this.def.fire / spdMult;
    if(fireRate < 0.05) fireRate = 0.05;
    this.cool -= dt;
    if(this.cool <= 0) {
      const isPiercing = this.def.type === 'pierce' || (this.def.id === 'sniper' && saveData.unlocked.includes('sniper_pierce'));
      if (isPiercing) {
        const targets = enemies.filter(e => e.alive && Math.hypot(e.visualPos.x-(this.x+0.5), e.visualPos.y-(this.y+0.5)) < range);
        if (targets.length > 0) {
           targets.sort((a,b) => b.progress - a.progress);
           const primary = targets[0];
           this.angle = Math.atan2(primary.visualPos.y-(this.y+0.5), primary.visualPos.x-(this.x+0.5));
           const hitList = this.getLineTargets(enemies, range, this.angle, this.def.pierce);
           hitList.forEach(e => {
             let finalDmg = dmg;
             if(this.def.id==='railgun') {
                const dist = Math.hypot(e.visualPos.x-(this.x+0.5), e.visualPos.y-(this.y+0.5));
                finalDmg *= Math.min(2.0, 1.0 + (dist/range));
                if(game.augments.railgunVuln) e.debuffs.vuln = 0.1;
              }
             if(game.augments.laserMark && this.def.id==='laser') e.debuffs.mark = (e.debuffs.mark||0) + 0.15;
             this.applyHit(e, finalDmg, isCrit, critLevel, {isPiercing:true});
           });
           let width = isCrit ? 4 : 2;
           if(this.def.id==='laser' && game.augments.laserWidth) width *= 1.5;
           const furthest = hitList[hitList.length-1] || primary;
           game.lasers.push({ x1:this.x+0.5, y1:this.y+0.5, x2:furthest.visualPos.x, y2:furthest.visualPos.y, color: isCrit ? '#fff' : this.def.color, width: width, life:5 });
           if(game.augments.beamShockAoe && this.def.id==='beam') {
               spawnParticles(furthest.visualPos.x, furthest.visualPos.y, '#8888ff', 5);
               enemies.forEach(sub => { if(sub.alive && Math.hypot(sub.visualPos.x-furthest.visualPos.x, sub.visualPos.y-furthest.visualPos.y) < 2.0) sub.takeDmg(dmg * 0.5, false, 'beam_shock'); });
           }
           this.cool = fireRate;
        }
      } else {
        const targets = enemies.filter(e => e.alive && Math.hypot(e.visualPos.x-(this.x+0.5), e.visualPos.y-(this.y+0.5)) < range);
        if(targets.length > 0) {
          targets.sort((a,b) => b.progress - a.progress);
          const target = targets[0];
          this.angle = Math.atan2(target.visualPos.y-(this.y+0.5), target.visualPos.x-(this.x+0.5));
          if(this.def.type === 'aoe' || this.def.type === 'aoe_prox') {
            let aoeRadius = 1.8;
            if (this.def.id === 'rocket') { aoeRadius = 2.2; if(game.augments.rocketAoe) aoeRadius *= 1.1; }
            if (this.def.id === 'blaster') { if(game.augments.blasterAoe) aoeRadius *= 1.1; if(game.augments.blasterAoeMult) aoeRadius *= game.augments.blasterAoeMult; }
            targets.forEach(e => {
              const dist = Math.hypot(e.visualPos.x-target.visualPos.x, e.visualPos.y-target.visualPos.y);
              if(dist < aoeRadius) {
                  let finalDmg = dmg;
                  if(this.def.type === 'aoe_prox') {
                      const towerDist = Math.hypot(e.visualPos.x-(this.x+0.5), e.visualPos.y-(this.y+0.5));
                      let prox = Math.max(0, 1.0 - (towerDist / range));
                      if(game.augments.blasterProx) prox += 0.2;
                      finalDmg = dmg * (1.0 + prox);
                      if(game.augments.blasterSlow) e.debuffs.slow = 0.1;
                  }
                  if(this.def.id === 'blaster' && this.tier >= 3 && ['tank','boss','elite','monolith'].includes(e.type)) finalDmg *= 1.5;
                  this.applyHit(e, finalDmg, isCrit, critLevel);
              }
            });
            spawnParticles(target.visualPos.x, target.visualPos.y, this.def.color, 8);
          } else {
            this.applyHit(target, dmg, isCrit, critLevel);
            if(this.def.id === 'beam' && this.tier >= 3) target.debuffs.slow = Math.max(target.debuffs.slow || 0, 0.1);
            if(isCrit) spawnParticles(target.visualPos.x, target.visualPos.y, '#fff', 4);
          }
          game.lasers.push({ x1:this.x+0.5, y1:this.y+0.5, x2:target.visualPos.x, y2:target.visualPos.y, color: isCrit ? '#fff' : this.def.color, width: isCrit ? 4 : 2, life:5 });
          if(this.def.id==='rocket' && game.augments.rocketSplit && targets.length > 1) this.applyHit(targets[1], dmg*0.5, isCrit, critLevel);
          this.cool = fireRate;
        }
      }
    }
  }
  applyHit(e, dmg, isCrit, critLevel=0, options) {
      e.takeDmg(dmg, isCrit, this.def.id, critLevel, options);
      spawnParticles(e.visualPos.x, e.visualPos.y, '#fff', 2);
      if(game.perks.doubleHit > 0 && Math.random() < game.perks.doubleHit) { setTimeout(() => { if(e.alive) { e.takeDmg(dmg, isCrit, this.def.id, critLevel, options); spawnParticles(e.visualPos.x, e.visualPos.y, '#00ffff', 4); }}, 100);
      }
  }
  getLineTargets(enemies, range, angle, maxHits) {
    const hits = [];
    const tx = this.x+0.5, ty = this.y+0.5; const dx = Math.cos(angle), dy = Math.sin(angle);
    const candidates = enemies.filter(e => e.alive).map(e => { return {e:e, dist: Math.hypot(e.visualPos.x-tx, e.visualPos.y-ty)}; }).sort((a,b) => a.dist - b.dist);
    for(let c of candidates) {
        if(c.dist > range) continue;
        const ex = c.e.visualPos.x, ey = c.e.visualPos.y;
        const dot = (ex-tx)*dx + (ey-ty)*dy;
        if (dot < 0) continue;
        const perpDist = Math.abs((ex-tx)*(-dy) + (ey-ty)*dx);
        if (perpDist < 0.5) { hits.push(c.e); if(hits.length >= maxHits) break;
        }
    }
    return hits;
  }
}

/* --- CORE FUNCTIONS --- */
function generatePath() {
  let p = []; let x=0; let y=Math.floor(GRID_H/2);
  while(x < GRID_W) {
    p.push({x,y}); x++;
    if(x<GRID_W && Math.random()<0.45) {
      let dy = Math.random()<0.5 ? -1 : 1;
      if(y+dy>1 && y+dy<GRID_H-2) { p.push({x,y}); y+=dy; p.push({x,y}); y+=dy;
      }
    }
  }
  return p;
}
function generateObstacles() {
    game.blocked = [];
    let attempts = 0;
    while(game.blocked.length < 10 && attempts < 1000) {
        let x = Math.floor(Math.random() * GRID_W);
        let y = Math.floor(Math.random() * GRID_H);
        if(!game.path.some(p => p.x===x && p.y===y) && !game.blocked.some(b => b.x===x && b.y===y)) { game.blocked.push({x,y});
        }
        attempts++;
    }
}
function triggerWave() {
  if(game.state !== 'idle') return;

  if (game.wave > 0) {
    let interestRate = 0.03 + game.perks.interest;
    let bonus = Math.floor(game.gold * interestRate);
    let cap = game.perks.interestCap !== undefined ? game.perks.interestCap : 99999;
    let finalInterest = Math.min(bonus, cap);
    if(finalInterest > 0) {
        game.gold += finalInterest;
        log(`INTEREST: +${finalInterest} CR (Rate:${(interestRate*100).toFixed(1)}%)`);
    }
  }

  game.lifeAtWaveStart = game.life;
  game.state = 'playing';
  game.wave++;
  game.waveStartTime = Date.now();
  document.getElementById('nextWaveBtn').disabled = true;
  selectDef = null; selectedTower = null;
  renderShop();
  if(game.perks.waveStartGold) game.gold += game.perks.waveStartGold;

  // Event Duration & Effect Management
  game.activeEvents.forEach(e => {
    e.duration--;
    if(e.duration <= 0 && e.onEnd) game.enemies.forEach(enemy => e.onEnd(enemy));
  });
  game.activeEvents = game.activeEvents.filter(e => e.duration > 0);

  if (Math.random() < 0.2 && game.wave > 1) {
      const availableEvents = WAVE_EVENTS.filter(ev => !game.activeEvents.some(ae => ae.id === ev.id));
      if (availableEvents.length > 0) {
          const ev = availableEvents[Math.floor(Math.random() * availableEvents.length)];
          const newEvent = {...ev};
          game.activeEvents.push(newEvent);
          if (newEvent.onStart) game.enemies.forEach(e => newEvent.onStart(e));
          log(`ANOMALY DETECTED: ${newEvent.name}`);
      }
  }

  const isBossWave = (game.wave % 10 === 0);
  let count = isBossWave ? 1 : (5 + Math.floor(game.wave * 1.8));
  game.enemiesToSpawn = count;
  game.enemiesSpawned = 0;
  game.spawnInterval = isBossWave ? 1.0 : Math.max(0.2, 0.8 - game.wave*0.03);
  game.spawnTimer = 0;

  if (isBossWave) log(`WARNING: BOSS DETECTED`);
}

function grantBossReward() {
    const lockedTowers = TOWERS.filter(t => !t.unlocked && t.id !== 'laser');
    if(lockedTowers.length > 0 && Math.random() < 0.5) {
        const t = lockedTowers[Math.floor(Math.random() * lockedTowers.length)];
        t.unlocked = true;
        log(`BOSS REWARD: BLUEPRINT FOUND - ${t.name} UNLOCKED`);
        spawnParticles(canvas.width/2, canvas.height/2, '#00ff88', 50);
        renderShop();
        return;
    }

    let rarityIdx = 2; // Rare
    if(Math.random() < 0.3) rarityIdx = 3;
    if(Math.random() < 0.05) rarityIdx = 4;

    let pool = [...BASE_ARTIFACTS, ...UNIQUE_ARTIFACTS];
    const type = pool[Math.floor(Math.random() * pool.length)];

    const u = { typeId: type.id, rarityIdx: type.rarityIdx || rarityIdx, name: type.name, baseDesc: type.desc, fn: type.fn, val: type.val };
    log(`BOSS DEFEATED! DROP: ${type.name}`);
    addArtifactRecursive(u);
}

function waveComplete(failed) {
  if(failed) {
      log("INTEGRITY LOST. RETRYING...");
      const overlay = document.getElementById('retryOverlay');
      overlay.classList.remove('hidden');
      setTimeout(() => { overlay.classList.add('hidden'); }, 1000);
      if(game.life <= 0) { gameOver(); return; }

      game.state = 'idle';
      game.wave--; game.enemies = []; game.particles = []; game.lasers = [];
      document.getElementById('nextWaveBtn').disabled = false;
      updateHUD(); return;
  }

  if(game.perks.cfGain > 0) { saveData.cf += game.perks.cfGain; saveGame(); log(`CF ACQUIRED: +${game.perks.cfGain}`); }

  if(game.bossKillBonusWave === game.wave) game.bossKillBonusWave = -1;

  if (game.wave % 4 === 0) {
      game.state = 'drafting';
      showDraftScreen();
  } else {
      game.state = 'idle';
      document.getElementById('nextWaveBtn').disabled = false;
      if(document.getElementById('autoStartCheck').checked) setTimeout(triggerWave, 500);
  }
}

function gameOver() {
  game.state = 'over';
  const cfEarned = Math.round(game.wave * 0.25 * (1 + (game.perks.cfGain||0)));
  saveData.cf += cfEarned;
  saveGame();

  document.getElementById('gameOverOverlay').classList.remove('hidden');
  document.getElementById('goWave').innerText = game.wave;
  document.getElementById('goCf').innerText = cfEarned;
}

function update() {
  if(!game || game.paused) return;

  const dtBase = 0.016;
  const dt = dtBase * game.speed;

  const now = Date.now();
  if(now - game.lastDpsUpdate > 1000) {
      updateDpsUI(); game.lastDpsUpdate = now;
      Object.keys(game.dpsCurrent).forEach(k => game.dpsCurrent[k] = 0);
  }

  game.particles.forEach(p => p.update());
  game.particles = game.particles.filter(p => p.life > 0);
  game.lasers = game.lasers.filter(l => {l.life--; return l.life>0;});
  game.dmgTexts.forEach(d => d.update());
  game.dmgTexts = game.dmgTexts.filter(d => d.life > 0);
  if(game.state === 'playing') {
    if(game.enemiesSpawned < game.enemiesToSpawn) {
        game.spawnTimer -= dt;
        if(game.spawnTimer <= 0) {
            let type = 'normal';
            const rand = Math.random();
            if (game.wave % 10 === 0) type = 'boss';
            else if (game.wave >= 20 && rand < 0.05) type = 'monolith';
            else if (game.wave >= 15 && rand < 0.20) type = 'elite';
            else if (game.wave >= 12 && rand < 0.20) type = 'tank';
            else if (game.wave >= 8 && rand < 0.20) type = 'ghost';
            else if (game.wave >= 5 && rand < 0.20) type = 'phase';

            const newEnemy = new Enemy(game.path, game.wave, type);
            game.activeEvents.forEach(ev => {
                if(ev.onStart) ev.onStart(newEnemy);
            });
            game.enemies.push(newEnemy);
            game.enemiesSpawned++;
            game.spawnTimer = game.spawnInterval;
        }
    }

    game.enemies.forEach(e => e.update(dt));
    game.towers.forEach(t => t.update(dt, game.enemies));
    game.enemies = game.enemies.filter(e => {
      if(!e.alive) {
        if(e.reached) { game.life--; if(game.life <= 0) gameOver(); }
        if(e.killed) {
            let bounty = 6 + game.wave * 0.5;
            if(e.type === 'boss') bounty *= 5; if(e.type === 'tank') bounty *= 2; if(e.type === 'elite') bounty *= 3; if(e.type === 'monolith') bounty *= 10;

            if(game.bossKillBonusWave === game.wave || game.activeEvents.some(ev => ev.special === 'gold_rush')) bounty *= 2;
            if(game.activeEvents.some(ev => ev.special === 'hyper_bounty')) bounty *= 3;

            game.gold += Math.floor(bounty);
        }
      }
      return e.alive;
    });
    if(game.enemies.length === 0 && game.enemiesSpawned >= game.enemiesToSpawn) {
       setTimeout(() => {
         if(game.state === 'playing' && game.enemies.length === 0) {
             if(game.life <= 0) gameOver();
             else if(game.life < game.lifeAtWaveStart) waveComplete(true);
             else waveComplete(false);
         }
       }, 500);
    }
  }
  updateHUD();
}

function loop() {
  if(!document.getElementById('gameScreen').classList.contains('hidden') && game && game.state !== 'over') {
      update();
      draw();
  }
  animationId = requestAnimationFrame(loop);
}

function draw() {
  if(!game) return;
  ctx.fillStyle = '#070b1a'; ctx.fillRect(0,0,canvas.width,canvas.height);
  const offX = (canvas.width - GRID_W*TILE)/2;
  const offY = (canvas.height - GRID_H*TILE)/2;
  ctx.save(); ctx.translate(offX, offY);

  if (game.activeEvents.some(e=>e.special==='night_vision')) {
      ctx.fillStyle = 'rgba(0,0,0,0.9)'; ctx.fillRect(-offX, -offY, canvas.width, canvas.height);
  }

  ctx.fillStyle = '#0f1724'; game.path.forEach(p => ctx.fillRect(p.x*TILE, p.y*TILE, TILE, TILE));
  ctx.fillStyle = '#1a1010'; ctx.strokeStyle = '#331111';
  game.blocked.forEach(b => { ctx.fillRect(b.x*TILE, b.y*TILE, TILE, TILE); ctx.strokeRect(b.x*TILE, b.y*TILE, TILE, TILE); });
  ctx.strokeStyle = '#1a273a'; ctx.lineWidth = 1;
  ctx.beginPath(); game.path.forEach((p,i) => { if(i===0) ctx.moveTo((p.x+0.5)*TILE, (p.y+0.5)*TILE); else ctx.lineTo((p.x+0.5)*TILE, (p.y+0.5)*TILE); }); ctx.stroke();
  game.towers.forEach(t => {
    ctx.fillStyle = t.def.color;
    if(t.def.type === 'support') {
         ctx.strokeStyle = t.def.color; ctx.lineWidth = 2;
         ctx.strokeRect((t.x+0.5)*TILE - TILE*0.35, (t.y+0.5)*TILE - TILE*0.35, TILE*0.7, TILE*0.7);
         ctx.font = "bold 10px sans-serif"; ctx.textAlign="center"; ctx.fillStyle=t.def.color;
         ctx.fillText("BUFF", (t.x+0.5)*TILE, (t.y+0.55)*TILE);
    } else {
         ctx.fillRect((t.x+0.5)*TILE - TILE*0.35, (t.y+0.5)*TILE - TILE*0.35, TILE*0.7, TILE*0.7);
         ctx.save(); ctx.translate((t.x+0.5)*TILE, (t.y+0.5)*TILE); ctx.rotate(t.angle); ctx.fillStyle = '#eee'; ctx.fillRect(0, -2, TILE*0.5, 4); ctx.restore();
    }
    ctx.fillStyle = "rgba(0,0,0,0.7)"; ctx.fillRect((t.x+0.45)*TILE, (t.y+0.6)*TILE, TILE*0.5, TILE*0.35);
    ctx.fillStyle = '#fff'; ctx.font = "bold " + (TILE*0.25) + "px sans-serif"; ctx.textAlign = "center"; ctx.fillText("Lv."+t.tier, (t.x+0.7)*TILE, (t.y+0.85)*TILE);
    if(selectedTower === t) { ctx.strokeStyle = '#fff';
      ctx.lineWidth = 2; ctx.strokeRect(t.x*TILE, t.y*TILE, TILE, TILE); }

    if(t.def.type === 'charge_shot' && t.charge > 0) {
        const cPct = Math.min(1, t.charge / 2.0);
        ctx.fillStyle = '#0f0'; ctx.fillRect((t.x+0.1)*TILE, (t.y+0.1)*TILE, TILE*0.8*cPct, 3);
        if(t.targetRef && t.targetRef.alive) {
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
            ctx.lineWidth = 1;
            ctx.beginPath(); ctx.moveTo((t.x+0.5)*TILE, (t.y+0.5)*TILE); ctx.lineTo(t.targetRef.visualPos.x*TILE, t.targetRef.visualPos.y*TILE); ctx.stroke();
        }
    }
  });
  game.enemies.forEach(e => {
    let color = '#ff4d4d'; let size = TILE*0.3;
    if (e.type === 'boss') { color = '#ff0000'; size = TILE*0.5; }
    if (e.type === 'tank') { color = '#558855'; size = TILE*0.45; }
    if (e.type === 'elite') color = '#ffff00';
    if (e.type === 'monolith') { color = '#333333'; size = TILE*0.6; }

    ctx.save();
    const isAnomalyRift = game.activeEvents.some(ev=>ev.special==='anomaly_rift');
    if (isAnomalyRift) ctx.globalAlpha = 0.5 + Math.sin(Date.now() / 100 + e.progress) * 0.5;

    ctx.fillStyle = color; ctx.beginPath(); ctx.arc(e.visualPos.x*TILE, e.visualPos.y*TILE, size, 0, Math.PI*2); ctx.fill();
    if(e.armor > 0) { ctx.strokeStyle = '#aaa'; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(e.visualPos.x*TILE, e.visualPos.y*TILE, size + 4, 0, Math.PI*2); ctx.stroke(); }
    if(e.type === 'monolith') { ctx.strokeStyle = '#ff0000'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(e.visualPos.x*TILE, e.visualPos.y*TILE, size, 0, Math.PI*2); ctx.stroke(); }
    ctx.restore();
    const hp = Math.max(0, e.hp/e.maxHp); const barY = e.visualPos.y*TILE-12 - (e.type==='boss'?10:0); const barX = e.visualPos.x*TILE-10;
    ctx.fillStyle = '#000';
    ctx.fillRect(barX-1, barY-1, 22, 5); ctx.fillStyle = '#500'; ctx.fillRect(barX, barY, 20, 3); ctx.fillStyle = '#f00'; ctx.fillRect(barX, barY, 20*hp, 3);
  });
  game.lasers.forEach(l => { ctx.strokeStyle = l.color; ctx.lineWidth = l.width || 2; ctx.globalAlpha = l.life/5; ctx.beginPath(); ctx.moveTo(l.x1*TILE, l.y1*TILE); ctx.lineTo(l.x2*TILE, l.y2*TILE); ctx.stroke(); });
  ctx.globalAlpha = 1;
  game.particles.forEach(p => p.draw(ctx, TILE));
  game.dmgTexts.forEach(d => d.draw(ctx, TILE));

  if(selectDef && mousePos && !game.paused) {
    const gx = Math.floor((mousePos.x - offX)/TILE);
    const gy = Math.floor((mousePos.y - offY)/TILE);
    if(gx>=0 && gx<GRID_W && gy>=0 && gy<GRID_H) {
        const isBlocked = game.path.some(p => p.x===gx && p.y===gy) || game.blocked.some(b => b.x===gx && b.y===gy) || game.towers.some(t=>t.x===gx && t.y===gy);
        ctx.strokeStyle = isBlocked ? '#f00' : selectDef.color; ctx.lineWidth = 2; ctx.strokeRect(gx*TILE, gy*TILE, TILE, TILE);
        if(!isBlocked) {
            let range = selectDef.range * TILE * (1+game.globalMult.range);
            if (game.activeEvents.some(e=>e.special==='night_vision') && selectDef.id !== 'sniper') range *= 0.6;

            if(selectDef.type === 'support') { ctx.fillStyle = selectDef.color;
              ctx.globalAlpha=0.2; ctx.fillRect((gx-1)*TILE, (gy-1)*TILE, TILE*3, TILE*3); }
            else { ctx.beginPath();
              ctx.arc((gx+0.5)*TILE, (gy+0.5)*TILE, range, 0, Math.PI*2); ctx.fillStyle = selectDef.color; ctx.globalAlpha=0.1; ctx.fill();
            }
            ctx.globalAlpha=1;
        }
    }
  }
  ctx.restore();
}

/* --- UI HELPERS --- */
function spawnParticles(x, y, c, n, life=1.0) { for(let i=0; i<n; i++) game.particles.push(new Particle(x,y,c, 0.2, life));
}
function log(m) { const l = document.getElementById('logContent'); const d = document.createElement('div'); d.className = 'log-entry'; d.innerText = `> ${m}`; l.prepend(d);
}
function updateHUD() {
  if (!game) return;
  document.getElementById('gold').innerText = Math.floor(game.gold);
  document.getElementById('life').innerText = game.life + " / " + game.maxLife;
  document.getElementById('wave').innerText = game.wave;

  const rushOverlay = document.getElementById('goldRushOverlay');
  if(game.bossKillBonusWave === game.wave || game.activeEvents.some(e=>e.special==='gold_rush')) rushOverlay.classList.remove('hidden');
  else rushOverlay.classList.add('hidden');

  const eventHud = document.getElementById('eventHud');
  eventHud.innerHTML = '';
  game.activeEvents.forEach(ev => {
      const el = document.createElement('div');
      el.className = `event-tag ${ev.type}`;
      el.innerText = `${ev.name} [${ev.duration}]`;
      el.onmouseenter = (e) => showTooltip(e, ev.desc);
      el.onmouseleave = hideTooltip;
      eventHud.appendChild(el);
  });

  const bosses = game.enemies.filter(e => e.type === 'boss' && e.alive);
  const hud = document.getElementById('bossHud');
  if(bosses.length > 0) {
      const boss = bosses[0];
      hud.classList.remove('hidden');
      const pct = Math.max(0, (boss.hp / boss.maxHp) * 100);
      document.getElementById('bossBarFill').style.width = pct + "%";
      document.getElementById('bossHpVal').innerText = Math.ceil(boss.hp) + " / " + Math.ceil(boss.maxHp);
  } else {
      hud.classList.add('hidden');
  }
}
function updateDpsUI() {
    const list = document.getElementById('dpsList'); list.innerHTML = '';
    let total = 0;
    const sorted = Object.entries(game.dpsCurrent).filter(([k,v]) => v > 0 || game.towerCounts[k] > 0).sort((a,b) => b[1] - a[1]);
    sorted.forEach(([k,v]) => total += v);
    if(total === 0 && sorted.length === 0) { list.innerHTML = '<div style="text-align:center;color:#444;">--</div>'; return;
    }
    sorted.forEach(([k, v]) => {
        const pct = total > 0 ? (v / total) * 100 : 0;
        const def = TOWERS.find(t=>t.id===k);
        if(!def) return;
        const color = def.color;
        const row = document.createElement('div'); row.className = 'dps-row';
        row.innerHTML = `<div class="dps-name" style="color:${color}">${k.toUpperCase().substring(0,4)}</div><div class="dps-bar-bg"><div class="dps-bar-fill" style="width:${pct}%; background:${color}"></div></div><div class="dps-val">${Math.floor(v)}</div>`;
        list.appendChild(row);
    });
}
function showDraftScreen() {
  renderCurrentStats('draftStats');
  const modal = document.getElementById('modalOverlay'); const container = document.getElementById('cards');
  document.getElementById('modalTitle').innerText = "WAVE CLEARED"; document.getElementById('modalSubtitle').innerText = "Select Artifact";
  container.innerHTML = ''; modal.classList.remove('hidden');
  let choicesCount = 3 + (saveData.unlocked.includes('art_draft_plus') ? 1 : 0);

  let currentMythicChance = game.perks.mythicChance + (saveData.unlocked.includes('art_mythic_chance_plus') ? 0.0005 : 0) + (saveData.unlocked.includes('art_mythic_plus_big') ? 0.001 : 0);
  if(game.activeEvents.some(e => e.special === 'mythic_chance_up')) currentMythicChance += 0.20;

  for(let i=0; i<choicesCount; i++) {
    let rarityIdx = 0; const r = Math.random();
    if(r < currentMythicChance && MYTHICS.some(m => !game.mythicHistory.has(m.id))) rarityIdx = 5;
    else if(r < 0.08 + (saveData.unlocked.includes('art_rare_up') ? 0.05 : 0)) rarityIdx = 2;
    else if(r < 0.35 + (saveData.unlocked.includes('art_uncommon_up') ? 0.05 : 0) - (saveData.unlocked.includes('art_common_down') ? 0.05 : 0)) rarityIdx = 1;

    if(rarityIdx === 5) {
        const availableMythics = MYTHICS.filter(m => !game.mythicHistory.has(m.id));
        if(availableMythics.length > 0) {
            const m = availableMythics[Math.floor(Math.random() * availableMythics.length)];
            createCard(container, {...m, rarityIdx: 5}, 5);
        } else {
             const type = ARTIFACT_TYPES[Math.floor(Math.random()*ARTIFACT_TYPES.length)];
             const u = { typeId:type.id, rarityIdx:4, name:type.name, baseDesc:type.desc, fn:type.fn, val:type.val };
             createCard(container, u, 4);
        }
    }
    else {
        let pool = rarityIdx === 2 ? [...BASE_ARTIFACTS, ...UNIQUE_ARTIFACTS] : BASE_ARTIFACTS;
        const type = pool[Math.floor(Math.random()*pool.length)];
        const u = { typeId:type.id, rarityIdx: rarityIdx, name:type.name, baseDesc:type.desc, fn:type.fn, val:type.val };
        createCard(container, u, rarityIdx);
    }
  }
}
function createCard(container, u, rarityIdx) {
    const el = document.createElement('div');
    const rName = RARITIES[rarityIdx]; el.className = `card ${rName}`;
    let html = `<h4>${u.name}</h4>`;
    if(u.val) html += `<p>${u.baseDesc.replace('[X]', u.val[rarityIdx])}</p><p style="font-size:0.65rem; color:#666; margin-top:5px;">Collect 3 to Synthesize</p>`;
    else html += `<p>${u.desc || u.baseDesc}</p>`;
    el.innerHTML = html;
    el.onclick = () => {
        if(u.rarity === 'mythic') {
            u.fn(game);
            game.artifacts.push({...u, rarity:'mythic', id: u.id, desc: u.desc});
            game.mythicHistory.add(u.id);
            log(`MYTHIC: ${u.name}`);
        } else addArtifactRecursive(u);
        document.getElementById('modalOverlay').classList.add('hidden');
        renderArtifacts();
        game.state = 'idle';
        document.getElementById('nextWaveBtn').disabled = false;
        if(document.getElementById('autoStartCheck').checked) setTimeout(triggerWave, 500);
    };
    container.appendChild(el);
}
function addArtifactRecursive(u) {
    const others = game.artifacts.filter(a => a.typeId === u.typeId && a.rarityIdx === u.rarityIdx);
    if(others.length >= 2) {
        let count = 0;
        game.artifacts = game.artifacts.filter(a => {
            if(a.typeId === u.typeId && a.rarityIdx === u.rarityIdx && count < 2) {
                count++; return false;
            }
            return true;
        });
        if(u.rarityIdx + 1 < RARITIES.length-1) { // Stop before mythic
             log(`SYNTHESIS: ${u.name} -> ${RARITIES[u.rarityIdx+1]}`);
             const nextU = { ...u, rarityIdx: u.rarityIdx + 1 };
             addArtifactRecursive(nextU);
        } else { // Reached legendary
            applyArtifactStats(u); game.artifacts.push(createArtifactData(u));
        }
    } else { applyArtifactStats(u); game.artifacts.push(createArtifactData(u)); log(`OBTAINED: ${u.name} (${RARITIES[u.rarityIdx]})`); }
}
function applyArtifactStats(u) {
    if(u.fn && u.val) u.fn(game, u.val[u.rarityIdx]);
    else if(u.fn) u.fn(game);
}
function createArtifactData(u) {
    return {typeId:u.typeId, rarityIdx:u.rarityIdx, rarity:RARITIES[u.rarityIdx], name:u.name, desc: u.val ? u.baseDesc.replace('[X]', u.val[u.rarityIdx]) : (u.desc || u.baseDesc)};
}
function renderArtifacts() {
  const d = document.getElementById('artifacts');
  d.innerHTML = '';

  game.artifacts.sort((a,b) => (b.rarity === 'mythic' ? 10 : b.rarityIdx) - (a.rarity === 'mythic' ? 10 : a.rarityIdx));

  const grouped = {};
  game.artifacts.forEach(a=>{
      const key = a.rarity === 'mythic' ? a.id : `${a.typeId}_${a.rarityIdx}`;
      if(!grouped[key]) grouped[key]={...a, count:0};
      grouped[key].count++;
  });

  Object.values(grouped).forEach(a=>{
      const el = document.createElement('div'); el.className=`artifact ${a.rarity}`; el.innerText=a.name[0];
      let tooltipText = `[${a.rarity.toUpperCase()}] ${a.name} x${a.count}\n${a.desc}`;
      el.onmouseenter = (e) => showTooltip(e, tooltipText);
      el.onmouseleave = hideTooltip;
      if(a.count>1) el.innerHTML+=`<div class="artifact-count">${a.count}</div>`; d.appendChild(el);
  });
}
function renderShop() {
  const c = document.getElementById('shopList'); c.innerHTML = '';
  TOWERS.forEach(t => {
    if(!t.unlocked) return;
    const currentCost = Math.floor(t.cost * (1 + 0.2 * game.towerCounts[t.id]));
    const b = document.createElement('button'); b.className = 'btn';
    if(game && game.gold < currentCost) b.disabled = true;
    if(selectDef && selectDef.id === t.id) b.style.borderColor = '#fff';
    b.innerHTML = `${t.name}<br><span style="font-size:0.8em;opacity:0.7">${currentCost} CR</span>`;

    let stats = `<strong style="color:${t.color}">[${t.name}]</strong>\nDMG: ${t.dmg} | RNG: ${t.range} | SPD: ${(1/t.fire).toFixed(1)}/s\n`;
    if(t.type === 'pierce') stats += `Pierce: ${t.pierce}`;
    else if(t.type === 'aoe' || t.type === 'aoe_prox') stats += `Type: AOE`;
    else if(t.type === 'charge_shot') stats += `Type: Charge Shot`;
    else if(t.type === 'support') stats += `Type: Support (Buffs Neighbors)`;
    else stats += `Type: Single Target`;

    b.onmouseenter = (e) => showTooltip(e, stats);
    b.onmouseleave = hideTooltip;
    b.onclick = () => { selectDef = t; selectedTower = null; renderShop(); };
    c.appendChild(b);
  });
}
function buyTech(type) {
  const cost = game.techCost[type];
  if(game.gold >= cost) {
    game.gold -= cost;
    if(type === 'life') { game.life = Math.min(game.life + 5, game.maxLife);
    game.techCost[type] = Math.floor(game.techCost[type] * 1.5); }
    else {
      if(type==='dmg') game.globalMult.dmg += 0.1;
      if(type==='range') game.globalMult.range += 0.1;
      if(type==='spd') game.globalMult.spd += 0.05;
      game.techCost[type] = Math.floor(game.techCost[type] * 1.3);
    }
    document.getElementById(`cost_${type}`).innerText = game.techCost[type];
    updateHUD();
  }
}
function getTowerCost(id) { return Math.floor(TOWERS.find(x=>x.id===id).cost * (1 + 0.2 * game.towerCounts[id])); }

/* --- INPUT --- */
window.onresize = resize;
function resize() {
  canvas.width = document.getElementById('left').clientWidth;
  canvas.height = document.getElementById('left').clientHeight;
  TILE = Math.min(canvas.width/GRID_W, canvas.height/GRID_H) * 0.9;
}
canvas.addEventListener('mousemove', e => {
  const r = canvas.getBoundingClientRect(); mousePos = {x:e.clientX-r.left, y:e.clientY-r.top};
});
canvas.addEventListener('click', () => {
  if(!game || game.state === 'over' || game.paused || document.getElementById('gameScreen').classList.contains('hidden')) return;
  const offX = (canvas.width - GRID_W*TILE)/2; const offY = (canvas.height - GRID_H*TILE)/2;
  const gx = Math.floor((mousePos.x - offX)/TILE); const gy = Math.floor((mousePos.y - offY)/TILE);
  if(gx<0 || gx>=GRID_W || gy<0 || gy>=GRID_H) return;

  const clickedTower = game.towers.find(t => t.x===gx && t.y===gy);

  if(selectDef) {
      if(game.path.some(p => p.x===gx && p.y===gy) || game.blocked.some(b => b.x===gx && b.y===gy) || clickedTower) { log("INVALID POSITION"); return; }
      const cost = getTowerCost(selectDef.id);
      if(game.gold >= cost) {
        game.gold -= cost; game.towerCounts[selectDef.id]++;
        const startTier = 1 + (game.globalMult.tierBonus || 0);
        game.towers.push(new Tower(gx, gy, selectDef, startTier));
        spawnParticles((gx+0.5), (gy+0.5), '#2ee6ff', 8); renderShop();
      } else log("NO CREDITS");
      return;
  }
  if(clickedTower) {
      if(selectedTower && selectedTower !== clickedTower && selectedTower.def.id === clickedTower.def.id && selectedTower.tier === clickedTower.tier) {
          clickedTower.tier++;
          game.towers = game.towers.filter(t => t !== selectedTower);
          spawnParticles((clickedTower.x+0.5), (clickedTower.y+0.5), '#fff', 20, 2.0);
          selectedTower = null;
          if(saveData.unlocked.includes('art_merge_bonus_perm')) game.globalMult.dmg += 0.01;
      } else { selectedTower = clickedTower; }
  } else { selectedTower = null; }
});
window.addEventListener('keydown', e => {
    if(e.code==='Escape') {
        if(selectDef || selectedTower) { selectDef = null; selectedTower = null; renderShop(); }
    }
    if(e.code==='Enter' && document.activeElement.id !== 'secretCode' && !document.getElementById('gameScreen').classList.contains('hidden') && !game.paused) {
        e.preventDefault();
        triggerWave();
    }
});
window.onload = function() {
    loadSave();
    returnToMenu();
};

</script>
</body>
</html>
